Welcome to the Emacs shell

~/workspace/haskel/udemy-lec $ stack ghci
Using main module: 1. Package `udemy-lec' component udemy-lec:exe:udemy-lec-exe with main-is file: /Users/codeguru/workspace/haskel/udemy-lec/app/Main.hs
The following GHC options are incompatible with GHCi and have not been passed to it: -threaded
Configuring GHCi with the following packages: udemy-lec

* * * * * * * *

Warning: Multiple files use the same module name:
         * Paths_udemy_lec found at the following paths
           * /Users/codeguru/workspace/haskel/udemy-lec/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Paths_udemy_lec.hs (udemy-lec:lib)
           * /Users/codeguru/workspace/haskel/udemy-lec/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/udemy-lec-exe/autogen/Paths_udemy_lec.hs (udemy-lec:exe:udemy-lec-exe)
* * * * * * * *

GHCi, version 8.10.4: https://www.haskell.org/ghc/  :? for help
[1 of 3] Compiling Lib              ( /Users/codeguru/workspace/haskel/udemy-lec/src/Lib.hs, interpreted )
[2 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/udemy-lec/app/Main.hs, interpreted )
[3 of 3] Compiling Paths_udemy_lec  ( /Users/codeguru/workspace/haskel/udemy-lec/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Paths_udemy_lec.hs, interpreted )
Ok, three modules loaded.
Loaded GHCi configuration from /private/var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/haskell-stack-ghci/d0f4789e/ghci-script
*Main Lib Paths_udemy_lec> :t Alternative

<interactive>:1:1: error:
    Data constructor not in scope: Alternative
*Main Lib Paths_udemy_lec> 
*Main Lib Paths_udemy_lec> :quit
Leaving GHCi.
~/workspace/haskel/udemy-lec $ cd ..
~/workspace/haskel $ ls
README.md     main.hs   myProjServant  to-do  udemy-lec
intellijProj  main.hs~  myProject      udemy  
~/workspace/haskel $ cd udemy
~/workspace/haskel/udemy $ ls
project
~/workspace/haskel/udemy $ cd project/
~/workspace/haskel/udemy/project $ ls
ChangeLog.md  README.md  app           project.cabal  stack.yaml
LICENSE       Setup.hs   package.yaml  src            test
~/workspace/haskel/udemy/project $ stack ghci
Using main module: 1. Package `project' component project:exe:project-exe with main-is file: /Users/codeguru/workspace/haskel/udemy/project/app/Main.hs
Building all executables for `project' once. After a successful build of all of them, only specified executables will be rebuilt.
project> configure (lib + exe)
Configuring project-0.1.0.0...
project> initial-build-steps (lib + exe)
The following GHC options are incompatible with GHCi and have not been passed to it: -threaded
Configuring GHCi with the following packages: project

* * * * * * * *

Warning: Multiple files use the same module name:
         * Paths_project found at the following paths
           * /Users/codeguru/workspace/haskel/udemy/project/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Paths_project.hs (project:lib)
           * /Users/codeguru/workspace/haskel/udemy/project/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/project-exe/autogen/Paths_project.hs (project:exe:project-exe)
* * * * * * * *

GHCi, version 8.10.4: https://www.haskell.org/ghc/  :? for help
[1 of 3] Compiling Lib              ( /Users/codeguru/workspace/haskel/udemy/project/src/Lib.hs, interpreted )
[2 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/udemy/project/app/Main.hs, interpreted )
[3 of 3] Compiling Paths_project    ( /Users/codeguru/workspace/haskel/udemy/project/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Paths_project.hs, interpreted )
Ok, three modules loaded.
Loaded GHCi configuration from /private/var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/haskell-stack-ghci/680b1eed/ghci-script
*Main Lib Paths_project> :t Alternative

<interactive>:1:1: error:
    Data constructor not in scope: Alternative
*Main Lib Paths_project> :t Int

<interactive>:1:1: error: Data constructor not in scope: Int
*Main Lib Paths_project> :i Functor
type Functor :: (* -> *) -> Constraint
class Functor f where
  fmap :: (a -> b) -> f a -> f b
  (<$) :: a -> f b -> f a
  {-# MINIMAL fmap #-}
  	-- Defined in ‘GHC.Base’
instance Functor (Either a) -- Defined in ‘Data.Either’
instance Functor [] -- Defined in ‘GHC.Base’
instance Functor Maybe -- Defined in ‘GHC.Base’
instance Functor IO -- Defined in ‘GHC.Base’
instance Functor ((->) r) -- Defined in ‘GHC.Base’
instance Functor ((,,,) a b c) -- Defined in ‘GHC.Base’
instance Functor ((,,) a b) -- Defined in ‘GHC.Base’
instance Functor ((,) a) -- Defined in ‘GHC.Base’
*Main Lib Paths_project> :i Alternative

<interactive>:1:1: error: Not in scope: ‘Alternative’
*Main Lib Paths_project> :type Functor

<interactive>:1:1: error: Data constructor not in scope: Functor
*Main Lib Paths_project> 
*Main Lib Paths_project> :show bindings
*Main Lib Paths_project> :i Applicative
type Applicative :: (* -> *) -> Constraint
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
  GHC.Base.liftA2 :: (a -> b -> c) -> f a -> f b -> f c
  (*>) :: f a -> f b -> f b
  (<*) :: f a -> f b -> f a
  {-# MINIMAL pure, ((<*>) | liftA2) #-}
  	-- Defined in ‘GHC.Base’
instance Applicative (Either e) -- Defined in ‘Data.Either’
instance Applicative [] -- Defined in ‘GHC.Base’
instance Applicative Maybe -- Defined in ‘GHC.Base’
instance Applicative IO -- Defined in ‘GHC.Base’
instance Applicative ((->) r) -- Defined in ‘GHC.Base’
instance (Monoid a, Monoid b, Monoid c) =>
         Applicative ((,,,) a b c)
  -- Defined in ‘GHC.Base’
instance (Monoid a, Monoid b) => Applicative ((,,) a b)
  -- Defined in ‘GHC.Base’
instance Monoid a => Applicative ((,) a) -- Defined in ‘GHC.Base’
*Main Lib Paths_project> :quit
Leaving GHCi.
~/workspace/haskel/udemy/project $ cd ..
~/workspace/haskel/udemy $ ls
project
~/workspace/haskel/udemy $ cd ..
~/workspace/haskel $ ls
README.md     main.hs   myProjServant  to-do  udemy-lec
intellijProj  main.hs~  myProject      udemy  
~/workspace/haskel $ cd udemy-lec/
~/workspace/haskel/udemy-lec $ ls
ChangeLog.md  Setup.hs      package.yaml~  stack.yaml.lock  udemy-lec.cabal
LICENSE       app           src            stack.yaml~      udemy-lec.cabal~
README.md     package.yaml  stack.yaml     test             
~/workspace/haskel/udemy-lec $ stack ghci
Using main module: 1. Package `udemy-lec' component udemy-lec:exe:udemy-lec-exe with main-is file: /Users/codeguru/workspace/haskel/udemy-lec/app/Main.hs
The following GHC options are incompatible with GHCi and have not been passed to it: -threaded
Configuring GHCi with the following packages: udemy-lec

* * * * * * * *

Warning: Multiple files use the same module name:
         * Paths_udemy_lec found at the following paths
           * /Users/codeguru/workspace/haskel/udemy-lec/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Paths_udemy_lec.hs (udemy-lec:lib)
           * /Users/codeguru/workspace/haskel/udemy-lec/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/udemy-lec-exe/autogen/Paths_udemy_lec.hs (udemy-lec:exe:udemy-lec-exe)
* * * * * * * *

GHCi, version 8.10.4: https://www.haskell.org/ghc/  :? for help
[1 of 3] Compiling Lib              ( /Users/codeguru/workspace/haskel/udemy-lec/src/Lib.hs, interpreted )
[2 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/udemy-lec/app/Main.hs, interpreted )
[3 of 3] Compiling Paths_udemy_lec  ( /Users/codeguru/workspace/haskel/udemy-lec/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Paths_udemy_lec.hs, interpreted )
Ok, three modules loaded.
Loaded GHCi configuration from /private/var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/haskell-stack-ghci/d0f4789e/ghci-script
*Main Lib Paths_udemy_lec> :t Command

<interactive>:1:1: error:
    • Data constructor not in scope: Command
    • Perhaps you meant variable ‘command’ (imported from Options.Applicative)
*Main Lib Paths_udemy_lec> :t command
command :: String -> ParserInfo a -> Mod CommandFields a
*Main Lib Paths_udemy_lec> 
*Main Lib Paths_udemy_lec> IsBigGang :: Int -> Bool

<interactive>:4:1: error:
    Data constructor not in scope: IsBigGang :: Int -> Bool
*Main Lib Paths_udemy_lec> :quit
Leaving GHCi.
~/workspace/haskel/udemy-lec $ ls
ChangeLog.md  Setup.hs      package.yaml~  stack.yaml.lock  udemy-lec.cabal
LICENSE       app           src            stack.yaml~      udemy-lec.cabal~
README.md     package.yaml  stack.yaml     test             
~/workspace/haskel/udemy-lec $ cd ..
~/workspace/haskel $ ls
README.md  main.hs~       myProject  udemy
main.hs    myProjServant  to-do      udemy-lec
~/workspace/haskel $ stack -help
Invalid option `-help'

Did you mean this?
    --help

Usage: stack [--help] [--version] [--numeric-version] [--hpack-numeric-version] 
             [--docker*] [--nix*] 
st             [--verbosity VERBOSITY | (-v|--verbose) | --silent] 
             [--[no-]time-in-log] [--stack-root STACK-ROOT] 
             [--work-dir WORK-DIR] [--[no-]system-ghc] [--[no-]install-ghc] 
             [--arch ARCH] [--ghc-variant VARIANT] [--ghc-build BUILD] 
             [-j|--jobs JOBS] [--extra-include-dirs DIR] [--extra-lib-dirs DIR] 
             [--custom-preprocessor-extensions EXT] [--with-gcc PATH-TO-GCC] 
             [--with-hpack HPACK] [--[no-]skip-ghc-check] [--[no-]skip-msys] 
             [--local-bin-path DIR] [--setup-info-yaml URL] 
             [--[no-]modify-code-page] [--[no-]allow-different-user] 
             [--[no-]dump-logs] [--color|--colour WHEN] 
             [--snapshot-location-base URL] [--resolver RESOLVER] 
             [--compiler COMPILER] [--[no-]terminal] 
             [--stack-colors|--stack-colours STYLES] [--terminal-width INT] 
             [--stack-yaml STACK-YAML] [--lock-file ARG] COMMAND|FILE
~/workspace/haskel $ st             [--verbosity VERBOSITY | (-v|--verbose) | --silent] 
--silent]: command not found
~/workspace/haskel $ stack --help
stack - The Haskell Tool Stack

Usage: stack [--help] [--version] [--numeric-version] [--hpack-numeric-version] 
             [--docker*] [--nix*] 
             [--verbosity VERBOSITY | (-v|--verbose) | --silent] 
             [--[no-]time-in-log] [--stack-root STACK-ROOT] 
             [--work-dir WORK-DIR] [--[no-]system-ghc] [--[no-]install-ghc] 
             [--arch ARCH] [--ghc-variant VARIANT] [--ghc-build BUILD] 
             [-j|--jobs JOBS] [--extra-include-dirs DIR] [--extra-lib-dirs DIR] 
             [--custom-preprocessor-extensions EXT] [--with-gcc PATH-TO-GCC] 
             [--with-hpack HPACK] [--[no-]skip-ghc-check] [--[no-]skip-msys] 
             [--local-bin-path DIR] [--setup-info-yaml URL] 
             [--[no-]modify-code-page] [--[no-]allow-different-user] 
             [--[no-]dump-logs] [--color|--colour WHEN] 
             [--snapshot-location-base URL] [--resolver RESOLVER] 
             [--compiler COMPILER] [--[no-]terminal] 
             [--stack-colors|--stack-colours STYLES] [--terminal-width INT] 
             [--stack-yaml STACK-YAML] [--lock-file ARG] COMMAND|FILE

Available options:
  --help                   Show this help text
  --version                Show version
  --numeric-version        Show only version number
  --hpack-numeric-version  Show only hpack's version number
  --docker*                Run 'stack --docker-help' for details
  --nix*                   Run 'stack --nix-help' for details
  --verbosity VERBOSITY    Verbosity: silent, error, warn, info, debug
  -v,--verbose             Enable verbose mode: verbosity level "debug"
  --silent                 Enable silent mode: verbosity level "silent"
  --[no-]time-in-log       Enable/disable inclusion of timings in logs, for the
                           purposes of using diff with logs (default: enabled)
  --stack-root STACK-ROOT  Absolute path to the global stack root directory
                           (Overrides any STACK_ROOT environment variable)
  --work-dir WORK-DIR      Relative path of work directory (Overrides any
                           STACK_WORK environment variable, default is
                           '.stack-work')
  --[no-]system-ghc        Enable/disable using the system installed GHC (on the
                           PATH) if it is available and its version matches.
                           Disabled by default.
  --[no-]install-ghc       Enable/disable downloading and installing GHC if
                           necessary (can be done manually with stack setup)
                           (default: enabled)
  --arch ARCH              System architecture, e.g. i386, x86_64
  --ghc-variant VARIANT    Specialized GHC variant, e.g. integersimple
                           (incompatible with --system-ghc)
  --ghc-build BUILD        Specialized GHC build, e.g. 'gmp4' or 'standard'
                           (usually auto-detected)
  -j,--jobs JOBS           Number of concurrent jobs to run
  --extra-include-dirs DIR Extra directories to check for C header files
  --extra-lib-dirs DIR     Extra directories to check for libraries
  --custom-preprocessor-extensions EXT
                           Extensions used for custom preprocessors
  --with-gcc PATH-TO-GCC   Use gcc found at PATH-TO-GCC
  --with-hpack HPACK       Use HPACK executable (overrides bundled Hpack)
  --[no-]skip-ghc-check    Enable/disable skipping the GHC version and
                           architecture check (default: disabled)
  --[no-]skip-msys         Enable/disable skipping the local MSYS installation
                           (Windows only) (default: disabled)
  --local-bin-path DIR     Install binaries to DIR
  --setup-info-yaml URL    Alternate URL or relative / absolute path for stack
                           dependencies
  --[no-]modify-code-page  Enable/disable setting the codepage to support UTF-8
                           (Windows only) (default: enabled)
  --[no-]allow-different-user
                           Enable/disable permission for users other than the
                           owner of the stack root directory to use a stack
                           installation (POSIX only) (default: true inside
                           Docker, otherwise false)
  --[no-]dump-logs         Enable/disable dump the build output logs for local
                           packages to the console (default: dump warning logs)
  --color,--colour WHEN    Specify when to use color in output; WHEN is
                           'always', 'never', or 'auto'. On Windows versions
                           before Windows 10, for terminals that do not support
                           color codes, the default is 'never'; color may work
                           on terminals that support color codes
  --snapshot-location-base URL
                           The base location of LTS/Nightly snapshots
  --resolver RESOLVER      Override resolver in project file
  --compiler COMPILER      Use the specified compiler
  --[no-]terminal          Enable/disable overriding terminal detection in the
                           case of running in a false terminal
  --stack-colors,--stack-colours STYLES
                           Specify stack's output styles; STYLES is a
                           colon-delimited sequence of key=value, where 'key' is
                           a style name and 'value' is a semicolon-delimited
                           list of 'ANSI' SGR (Select Graphic Rendition) control
                           codes (in decimal). Use 'stack ls stack-colors
                           --basic' to see the current sequence. In shells where
                           a semicolon is a command separator, enclose STYLES in
                           quotes.
  --terminal-width INT     Specify the width of the terminal, used for
                           pretty-print messages
  --stack-yaml STACK-YAML  Override project stack.yaml file (overrides any
                           STACK_YAML environment variable)
  --lock-file ARG          Specify how to interact with lock files. Default:
                           read/write. If resolver is overridden: read-only

Available commands:
  build                    Build the package(s) in this directory/configuration
  install                  Shortcut for 'build --copy-bins'
  uninstall                DEPRECATED: This command performs no actions, and is
                           present for documentation only
  test                     Shortcut for 'build --test'
  bench                    Shortcut for 'build --bench'
  haddock                  Shortcut for 'build --haddock'
  new                      Create a new project from a template. Run `stack
                           templates' to see available templates. Note: you can
                           also specify a local file or a remote URL as a
                           template.
  templates                Show how to find templates available for `stack new'.
                           `stack new' can accept a template from a remote
                           repository (default: github), local file or remote
                           URL. Note: this downloads the help file.
  init                     Create stack project config from cabal or hpack
                           package specifications
  setup                    Get the appropriate GHC for your project
  path                     Print out handy path information
  ls                       List command. (Supports snapshots, dependencies and
                           stack's styles)
  unpack                   Unpack one or more packages locally
  update                   Update the package index
  upgrade                  Upgrade to the latest stack
  upload                   Upload a package to Hackage
  sdist                    Create source distribution tarballs
  dot                      Visualize your project's dependency graph using
                           Graphviz dot
  ghc                      Run ghc
  hoogle                   Run hoogle, the Haskell API search engine. Use the
                           '-- ARGUMENT(S)' syntax to pass Hoogle arguments,
                           e.g. stack hoogle -- --count=20, or stack hoogle --
                           server --local.
  exec                     Execute a command. If the command is absent, the
                           first of any arguments is taken as the command.
  run                      Build and run an executable. Defaults to the first
                           available executable if none is provided as the first
                           argument.
  ghci                     Run ghci in the context of package(s) (experimental)
  repl                     Run ghci in the context of package(s) (experimental)
                           (alias for 'ghci')
  runghc                   Run runghc
  runhaskell               Run runghc (alias for 'runghc')
  script                   Run a Stack Script
  eval                     Evaluate some haskell code inline. Shortcut for
                           'stack exec ghc -- -e CODE'
  clean                    Delete build artefacts for the project packages.
  purge                    Delete the project stack working directories
                           (.stack-work by default). Shortcut for 'stack clean
                           --full'
  query                    Query general build information (experimental)
  list                     List package id's in snapshot (experimental)
  ide                      IDE-specific commands
  docker                   Subcommands specific to Docker use
  config                   Subcommands for accessing and modifying configuration
                           values
  hpc                      Subcommands specific to Haskell Program Coverage

stack's documentation is available at https://docs.haskellstack.org/
~/workspace/haskel $   hpc                      Subcommands specific to Haskell Program Coverage
hpc: command not found
~/workspace/haskel $ stack new HaskellForGreaterGood
Downloading template "new-template" to create project "HaskellForGreaterGood" in HaskellForGreaterGood/ ...

The following parameters were needed by the template but not provided: author-name
You can provide them in /Users/codeguru/.stack/config.yaml, like this:
templates:
  params:
    author-name: value
Or you can pass each one as parameters like this:
stack new HaskellForGreaterGood new-template -p "author-name:value"


The following parameters were needed by the template but not provided: author-email, author-name, category, copyright, github-username
You can provide them in /Users/codeguru/.stack/config.yaml, like this:
templates:
  params:
    author-email: value
    author-name: value
    category: value
    copyright: value
    github-username: value
Or you can pass each one as parameters like this:
stack new HaskellForGreaterGood new-template -p "author-email:value" -p "author-name:value" -p "category:value" -p "copyright:value" -p "github-username:value"

Looking for .cabal or package.yaml files to use to init the project.
Using cabal packages:
- HaskellForGreaterGood/

Selecting the best among 20 snapshots...

* Matches https://raw.githubusercontent.com/commercialhaskell/stackage-snapshots/master/lts/18/2.yaml

Selected resolver: https://raw.githubusercontent.com/commercialhaskell/stackage-snapshots/master/lts/18/2.yaml
Initialising configuration using resolver: https://raw.githubusercontent.com/commercialhaskell/stackage-snapshots/master/lts/18/2.yaml
Total number of user packages considered: 1
Writing configuration to file: HaskellForGreaterGood/stack.yaml
All done.
/Users/codeguru/.stack/templates/new-template.hsfiles:    6.06 KiB downloaded...
~/workspace/haskel $ cd HaskellForGreaterGood/
~/workspace/haskel/HaskellForGreaterGood $ ls
ChangeLog.md                 LICENSE    Setup.hs  package.yaml  stack.yaml
HaskellForGreaterGood.cabal  README.md  app       src           test
~/workspace/haskel/HaskellForGreaterGood $ stack ghci
Using main module: 1. Package `HaskellForGreaterGood' component HaskellForGreaterGood:exe:HaskellForGreaterGood-exe with main-is file: /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs
Building all executables for `HaskellForGreaterGood' once. After a successful build of all of them, only specified executables will be rebuilt.
HaskellForGreaterGood> configure (lib + exe)
Configuring HaskellForGreaterGood-0.1.0.0...
HaskellForGreaterGood> initial-build-steps (lib + exe)
The following GHC options are incompatible with GHCi and have not been passed to it: -threaded
Configuring GHCi with the following packages: HaskellForGreaterGood

* * * * * * * *

Warning: Multiple files use the same module name:
         * Paths_HaskellForGreaterGood found at the following paths
           * /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/autogen/Paths_HaskellForGreaterGood.hs (HaskellForGreaterGood:exe:HaskellForGreaterGood-exe)
           * /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Paths_HaskellForGreaterGood.hs (HaskellForGreaterGood:lib)
* * * * * * * *

GHCi, version 8.10.4: https://www.haskell.org/ghc/  :? for help
[1 of 3] Compiling Lib              ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Lib.hs, interpreted )
[2 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
[3 of 3] Compiling Paths_HaskellForGreaterGood ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Paths_HaskellForGreaterGood.hs, interpreted )
Ok, three modules loaded.
Loaded GHCi configuration from /private/var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/haskell-stack-ghci/e60d3411/ghci-script
*Main Lib Paths_HaskellForGreaterGood> isBigGang 6

<interactive>:1:1: error:
    Variable not in scope: isBigGang :: t0 -> t
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> isBigGang 4
False
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> isBigGang 4
(False,"hello Big Gang")
*Main Lib Paths_HaskellForGreaterGood> isBigGang 10
(True,"hello Big Gang")
*Main Lib Paths_HaskellForGreaterGood> isBigGang `applyLog` (\x -> (x*4, "happy")

<interactive>:7:43: error:
    parse error (possibly incorrect indentation or mismatched brackets)
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> isBigGang `applyLog` (\x -> (x*3, "appending text")

<interactive>:9:52: error:
    parse error (possibly incorrect indentation or mismatched brackets)
*Main Lib Paths_HaskellForGreaterGood> (3, "first text") `applyLog` isBigGAng

<interactive>:10:30: error:
    • Variable not in scope: isBigGAng :: a0 -> (b, String)
    • Perhaps you meant ‘isBigGang’ (line 5)
*Main Lib Paths_HaskellForGreaterGood> (3, "first text) `applyLog` isBigGang

<interactive>:11:38: error:
    lexical error in string/character literal at end of input
*Main Lib Paths_HaskellForGreaterGood> (4, "first text") `applyLog` isBigGang
(False,"first texthello Big Gang")
*Main Lib Paths_HaskellForGreaterGood> :t isBigGang
isBigGang :: Int -> (Bool, String)
*Main Lib Paths_HaskellForGreaterGood> (10, "large armored man") `applyLog` isBigGang
(True,"large armored manhello Big Gang")
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> (100, "large platoon") `applyLog` isBigGang
(True,"large platoon is Big Gang")
*Main Lib Paths_HaskellForGreaterGood> [1,2,3] `mappend` [4,5,6]
[1,2,3,4,5,6]
*Main Lib Paths_HaskellForGreaterGood> :t B.pack

<interactive>:1:1: error:
    Not in scope: ‘B.pack’
    No module named ‘B’ is imported.
*Main Lib Paths_HaskellForGreaterGood> :t B

<interactive>:1:1: error: Data constructor not in scope: B
*Main Lib Paths_HaskellForGreaterGood> :i B.pack

<interactive>:1:1: error: Not in scope: ‘B.pack’
*Main Lib Paths_HaskellForGreaterGood> B.pack [99,104,105] `mappend` B.pack [104,117,97,104,117,97]

<interactive>:21:1: error:
    Not in scope: ‘B.pack’
    No module named ‘B’ is imported.

<interactive>:21:31: error:
    Not in scope: ‘B.pack’
    No module named ‘B’ is imported.
*Main Lib Paths_HaskellForGreaterGood> :t Sum

<interactive>:1:1: error:
    • Data constructor not in scope: Sum
    • Perhaps you meant variable ‘sum’ (imported from Prelude)
*Main Lib Paths_HaskellForGreaterGood> :i Sum

<interactive>:1:1: error: Not in scope: ‘Sum’
*Main Lib Paths_HaskellForGreaterGood> Sum 3 `mappend` Sum 2

<interactive>:24:1: error:
    • Data constructor not in scope: Sum :: t0 -> a
    • Perhaps you meant variable ‘sum’ (imported from Prelude)

<interactive>:24:17: error:
    • Data constructor not in scope: Sum :: t1 -> a
    • Perhaps you meant variable ‘sum’ (imported from Prelude)
*Main Lib Paths_HaskellForGreaterGood> :t Sum 3

<interactive>:1:1: error:
    • Data constructor not in scope: Sum :: t0 -> t
    • Perhaps you meant variable ‘sum’ (imported from Prelude)
*Main Lib Paths_HaskellForGreaterGood> :i Sum 3

<interactive>:1:1: error: Not in scope: ‘Sum’
*Main Lib Paths_HaskellForGreaterGood> :m + Data.Monoid
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> :t Sum
Sum :: a -> Sum a
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> Sum 3 `mappend` Sum 2
Sum {getSum = 5}
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> :i Data.Monoid

<interactive>:1:1: error: Not in scope: ‘Data.Monoid’
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> :t Data.Monoid

<interactive>:1:1: error:
    Not in scope: data constructor ‘Data.Monoid’
    Perhaps you meant ‘Data.Monoid.Ap’ (imported from Data.Monoid)
    No module named ‘Data’ is imported.
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> :k Data.Monoid

<interactive>:1:1: error:
    Not in scope: type constructor or class ‘Data.Monoid’
    Perhaps you meant ‘Data.Monoid.Ap’ (imported from Data.Monoid)
    No module named ‘Data’ is imported.
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> ("beens", Sum 10) `applyLogM` addDrink

<interactive>:33:19: error:
    • Variable not in scope: applyLogM :: ([Char], Sum a0) -> t0 -> t
    • Perhaps you meant ‘applyLog’ (line 7)

<interactive>:33:31: error: Variable not in scope: addDrink
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> ("Beans", Sum 10) `applyLogM` addDrink

<interactive>:34:19: error:
    • Variable not in scope: applyLogM :: ([Char], Sum a0) -> t0 -> t
    • Perhaps you meant ‘applyLog’ (line 7)

<interactive>:34:31: error: Variable not in scope: addDrink
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> ("Beans", Sum 10) `applyLogM` addDrink
("milk",Sum {getSum = 35})
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> 
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> :t Sum
Sum :: a -> Sum a
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> :t Sum a

<interactive>:1:5: error: Variable not in scope: a
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> :t Sum
Sum :: a -> Sum a
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> :i Sum
type Sum :: * -> *
newtype Sum a = Sum {getSum :: a}
  	-- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Applicative Sum
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Eq a => Eq (Sum a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Functor Sum
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Monad Sum
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Num a => Monoid (Sum a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Ord a => Ord (Sum a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Num a => Semigroup (Sum a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Num a => Num (Sum a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Show a => Show (Sum a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Read a => Read (Sum a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Bounded a => Bounded (Sum a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Foldable Sum -- Defined in ‘Data.Foldable’
instance Traversable Sum -- Defined in ‘Data.Traversable’
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> 
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> :t Writer

<interactive>:1:1: error: Data constructor not in scope: Writer
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> :t Writer w a

<interactive>:1:1: error:
    Data constructor not in scope: Writer :: t0 -> t1 -> t

<interactive>:1:8: error: Variable not in scope: w

<interactive>:1:10: error: Variable not in scope: a
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> :i Writer

<interactive>:1:1: error: Not in scope: ‘Writer’
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> :t Writer
Writer :: (a, w) -> Writer w a
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> :i Writer
type Writer :: * -> * -> *
newtype Writer w a = Writer {runWriter :: (a, w)}
  	-- Defined at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:17:1
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> :t runWriter
runWriter :: Writer w a -> (a, w)
*Main Lib Paths_HaskellForGreaterGood Data.Monoid> :quit
Leaving GHCi.
~/workspace/haskel/HaskellForGreaterGood $ *Main Lib Paths_udemy_lec> IsBigGang :: Int -> Bool
Main: external command not found
~/workspace/haskel/HaskellForGreaterGood $ stack ghci
Using main module: 1. Package `HaskellForGreaterGood' component HaskellForGreaterGood:exe:HaskellForGreaterGood-exe with main-is file: /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs
The following GHC options are incompatible with GHCi and have not been passed to it: -threaded
Configuring GHCi with the following packages: HaskellForGreaterGood

* * * * * * * *

Warning: Multiple files use the same module name:
         * Paths_HaskellForGreaterGood found at the following paths
           * /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/autogen/Paths_HaskellForGreaterGood.hs (HaskellForGreaterGood:exe:HaskellForGreaterGood-exe)
           * /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Paths_HaskellForGreaterGood.hs (HaskellForGreaterGood:lib)
* * * * * * * *

GHCi, version 8.10.4: https://www.haskell.org/ghc/  :? for help
[1 of 3] Compiling Lib              ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Lib.hs, interpreted )
[2 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
[3 of 3] Compiling Paths_HaskellForGreaterGood ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Paths_HaskellForGreaterGood.hs, interpreted )
Ok, three modules loaded.
Loaded GHCi configuration from /private/var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/haskell-stack-ghci/e60d3411/ghci-script
*Main Lib Paths_HaskellForGreaterGood> :t Writer
Writer :: (a, w) -> Writer w a
*Main Lib Paths_HaskellForGreaterGood> :t runWriter
runWriter :: Writer w a -> (a, w)
*Main Lib Paths_HaskellForGreaterGood> runWriter (return 3 :: Writer String Int)
(3,"")
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> runWriter (return 3 :: Writer (Sum Int) Int)
(3,Sum {getSum = 0})
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> runWriter (return 3 :: (Product Int) Int)

<interactive>:7:24: error:
    • Expected kind ‘* -> *’, but ‘Product Int’ has kind ‘*’
    • In an expression type signature: (Product Int) Int
      In the first argument of ‘runWriter’, namely
        ‘(return 3 :: (Product Int) Int)’
      In the expression: runWriter (return 3 :: (Product Int) Int)
*Main Lib Paths_HaskellForGreaterGood> runWriter (return 3 :: (Product Int) Int)

<interactive>:8:24: error:
    • Expected kind ‘* -> *’, but ‘Product Int’ has kind ‘*’
    • In an expression type signature: (Product Int) Int
      In the first argument of ‘runWriter’, namely
        ‘(return 3 :: (Product Int) Int)’
      In the expression: runWriter (return 3 :: (Product Int) Int)
*Main Lib Paths_HaskellForGreaterGood> runWriter (return 3 :: Writer (Product Int) Int)
(3,Product {getProduct = 1})
*Main Lib Paths_HaskellForGreaterGood> :r
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> :e
editor not set, use :set editor
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> runWriter multWithLog
(15,["Got Number: 3","Got Number: 5"])
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:32:3: error:
    Variable not in scope: tell :: [[Char]] -> Writer [String] a0
   |
32 |   tell ["Gonna multiply these two"]
   |   ^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> runWriter multWithLog
(15,["Got Number: 3","Got Number: 5","Gonna multiply these two"])
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> gcd' 8 3
1
*Main Lib Paths_HaskellForGreaterGood> gcd' 16 8
8
*Main Lib Paths_HaskellForGreaterGood> gcd' 8 16
8
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> fst $ runWriter (gcd'' 8 3)
1
*Main Lib Paths_HaskellForGreaterGood> runWriter (gcd'' 8 3)
(1,["8 mod 3 = 2","3 mod 2 = 1","2 mod 1 = 0","Finished with1"])
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> Lr

<interactive>:27:1: error:
    • Data constructor not in scope: Lr
    • Perhaps you meant one of these:
        ‘LT’ (imported from Prelude), variable ‘or’ (imported from Prelude)
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood
*Main Lib Paths_HaskellForGreaterGood> runWriter (gcd'' 8 3)
(1,["8 mod 3 = 2","3 mod 2 = 1","2 mod 1 = 0","Finished with 1"])
*Main Lib Paths_HaskellForGreaterGood> runWriter (gcd'' 202 5)
(1,["202 mod 5 = 2","5 mod 2 = 1","2 mod 1 = 0","Finished with 1"])
*Main Lib Paths_HaskellForGreaterGood> runWriter (gcd'' 1231 2321)
(1,["1231 mod 2321 = 1231","2321 mod 1231 = 1090","1231 mod 1090 = 141","1090 mod 141 = 103","141 mod 103 = 38","103 mod 38 = 27","38 mod 27 = 11","27 mod 11 = 5","11 mod 5 = 1","5 mod 1 = 0","Finished with 1"])
*Main Lib Paths_HaskellForGreaterGood> :t mapM
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
*Main Lib Paths_HaskellForGreaterGood
*Main Lib Paths_HaskellForGreaterGood> :t mapM_
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
*Main Lib Paths_HaskellForGreaterGood> mapM_ putStrLn $ snd $ runWriter (gcd'' 8 3)
8 mod 3 = 2
3 mod 2 = 1
2 mod 1 = 0
Finished with 1
*Main Lib Paths_HaskellForGreaterGood> :e
editor not set, use :set editor
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])

<interactive>:40:1: error:
    • Non type-variable argument in the constraint: Monoid (DiffList a)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall a. (Monoid (DiffList a), Num a) => [a]
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:1:1: error:
    parse error on input ‘:’
  |
1 | :set -XFlexibleContexts
  | ^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> :t putStrLn
putStrLn :: String -> IO ()
*Main Lib Paths_HaskellForGreaterGood
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])

<interactive>:45:1: error:
    • Non type-variable argument in the constraint: Monoid (DiffList a)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall a. (Monoid (DiffList a), Num a) => [a]
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])

<interactive>:46:1: error:
    • Non type-variable argument in the constraint: Monoid (DiffList a)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall a. (Monoid (DiffList a), Num a) => [a]
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:56:1: error:
    Parse error: module header, import declaration
    or top-level declaration expected.
   |
56 | fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])

<interactive>:49:1: error:
    • Non type-variable argument in the constraint: Monoid (DiffList a)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall a. (Monoid (DiffList a), Num a) => [a]
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])

<interactive>:51:1: error:
    • Non type-variable argument in the constraint: Monoid (DiffList a)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall a. (Monoid (DiffList a), Num a) => [a]
*Main Lib Paths_HaskellForGreaterGood> :i Semigroup
type Semigroup :: * -> Constraint
class Semigroup a where
  (<>) :: a -> a -> a
  GHC.Base.sconcat :: GHC.Base.NonEmpty a -> a
  GHC.Base.stimes :: Integral b => b -> a -> a
  {-# MINIMAL (<>) #-}
  	-- Defined in ‘GHC.Base’
instance Semigroup (Either a b) -- Defined in ‘Data.Either’
instance Num a => Semigroup (Sum a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Num a => Semigroup (Product a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Semigroup (Endo a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Semigroup a => Semigroup (Dual a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Semigroup Any
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance GHC.Base.Alternative f => Semigroup (Alt f a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Semigroup All
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Semigroup (Last a) -- Defined in ‘Data.Monoid’
instance Semigroup (First a) -- Defined in ‘Data.Monoid’
instance (Applicative f, Semigroup a) => Semigroup (Ap f a)
  -- Defined in ‘Data.Monoid’
instance Semigroup [a] -- Defined in ‘GHC.Base’
instance Semigroup Ordering -- Defined in ‘GHC.Base’
instance Semigroup a => Semigroup (Maybe a)
  -- Defined in ‘GHC.Base’
instance Semigroup a => Semigroup (IO a) -- Defined in ‘GHC.Base’
instance Semigroup b => Semigroup (a -> b) -- Defined in ‘GHC.Base’
instance (Semigroup a, Semigroup b, Semigroup c, Semigroup d,
          Semigroup e) =>
         Semigroup (a, b, c, d, e)
  -- Defined in ‘GHC.Base’
instance (Semigroup a, Semigroup b, Semigroup c, Semigroup d) =>
         Semigroup (a, b, c, d)
  -- Defined in ‘GHC.Base’
instance (Semigroup a, Semigroup b, Semigroup c) =>
         Semigroup (a, b, c)
  -- Defined in ‘GHC.Base’
instance (Semigroup a, Semigroup b) => Semigroup (a, b)
  -- Defined in ‘GHC.Base’
instance Semigroup () -- Defined in ‘GHC.Base’
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])

<interactive>:53:1: error:
    • Non type-variable argument in the constraint: Monoid (DiffList a)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall a. (Monoid (DiffList a), Num a) => [a]
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> :e
editor not set, use :set editor
*Main Lib Paths_HaskellForGreaterGood> :e
editor not set, use :set editor
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:52:28: error:
    • Expected a type, but ‘Num a’ has kind ‘Constraint’
    • In the first argument of ‘DiffList’, namely ‘(Num a)’
      In the first argument of ‘Monoid’, namely ‘(DiffList (Num a))’
      In the instance declaration for ‘Monoid (DiffList (Num a))’
   |
52 | instance Monoid (DiffList (Num a)) where
   |                            ^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:52:10: error:
    Illegal class instance: ‘(Monoid (DiffList a), Num a)’
      Class instances must be of the form
        context => C ty_1 ... ty_n
      where ‘C’ is a class
   |
52 | instance (Monoid (DiffList a), Num a) where
   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])
[1,2,3,4,1,2,3]
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:52:10: error:
    • Could not deduce (Semigroup (DiffList a))
        arising from the superclasses of an instance declaration
      from the context: Num a
        bound by the instance declaration
        at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:52:10-37
    • In the instance declaration for ‘Monoid (DiffList a)’
   |
52 | instance Num a => Monoid (DiffList a) where
   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])
[1,2,3,4,1,2,3]
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:7: error:
    • Couldn't match type ‘[String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [String] Int
    • In a stmt of a 'do' block:
        tell (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tell (toDiffList ["Finished with " ++ show a])
           return a
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tell (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tell
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
74 |       tell (toDiffList ["Finished with " ++ show a])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:13: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tell’, namely
        ‘(toDiffList ["Finished with " ++ show a])’
      In a stmt of a 'do' block:
        tell (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tell (toDiffList ["Finished with " ++ show a])
           return a
   |
74 |       tell (toDiffList ["Finished with " ++ show a])
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:78:7: error:
    • Couldn't match type ‘[String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [String] Int
    • In a stmt of a 'do' block:
        tell
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tell
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tell (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tell
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
78 |       tell (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:78:13: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tell’, namely
        ‘(toDiffList
            [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])’
      In a stmt of a 'do' block:
        tell
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tell
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
   |
78 |       tell (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:7: error:
    • Couldn't match type ‘[String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [String] Int
    • In a stmt of a 'do' block:
        tell (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tell (toDiffList ["Finished with " ++ show a])
           return a
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tell (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tell
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
74 |       tell (toDiffList ["Finished with " ++ show a])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:13: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tell’, namely
        ‘(toDiffList ["Finished with " ++ show a])’
      In a stmt of a 'do' block:
        tell (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tell (toDiffList ["Finished with " ++ show a])
           return a
   |
74 |       tell (toDiffList ["Finished with " ++ show a])
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:78:7: error:
    • Couldn't match type ‘[String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [String] Int
    • In a stmt of a 'do' block:
        tell
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tell
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tell (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tell
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
78 |       tell (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:78:13: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tell’, namely
        ‘(toDiffList
            [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])’
      In a stmt of a 'do' block:
        tell
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tell
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
   |
78 |       tell (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:7: error:
    • Couldn't match type ‘[String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [String] Int
    • In a stmt of a 'do' block:
        tell (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tell (toDiffList ["Finished with " ++ show a])
           return a
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tell (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tell
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
74 |       tell (toDiffList ["Finished with " ++ show a])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:13: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tell’, namely
        ‘(toDiffList ["Finished with " ++ show a])’
      In a stmt of a 'do' block:
        tell (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tell (toDiffList ["Finished with " ++ show a])
           return a
   |
74 |       tell (toDiffList ["Finished with " ++ show a])
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:78:7: error:
    • Couldn't match type ‘[String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [String] Int
    • In a stmt of a 'do' block:
        tell
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tell
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tell (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tell
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
78 |       tell (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:78:13: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tell’, namely
        ‘(toDiffList
            [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])’
      In a stmt of a 'do' block:
        tell
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tell
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
   |
78 |       tell (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3]

<interactive>:73:64: error:
    parse error (possibly incorrect indentation or mismatched brackets)
*Main Lib Paths_HaskellForGreaterGood>fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3]

<interactive>:74:64: error:
    parse error (possibly incorrect indentation or mismatched brackets)
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])

<interactive>:75:1: error:
    • Ambiguous type variable ‘a0’ arising from a use of ‘print’
      prevents the constraint ‘(Show a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      These potential instances exist:
        instance (Show a, Show b) => Show (Either a b)
          -- Defined in ‘Data.Either’
        instance forall k (f :: k -> *) (a :: k).
                 Show (f a) =>
                 Show (Ap f a)
          -- Defined in ‘Data.Monoid’
        instance Show a => Show (First a) -- Defined in ‘Data.Monoid’
        ...plus 32 others
        ...plus 66 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In a stmt of an interactive GHCi command: print it
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:52:10: error:
    • Expected kind ‘* -> Constraint’,
        but ‘(Monoid, Show)’ has kind ‘*’
    • In the instance declaration for ‘Monoid (DiffList a)’
   |
52 | instance (Monoid, Show) a => Monoid (DiffList a) where
   |          ^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:52:11: error:
    • Expecting one more argument to ‘Monoid’
      Expected a type, but ‘Monoid’ has kind ‘* -> Constraint’
    • In the instance declaration for ‘Monoid (DiffList a)’
   |
52 | instance (Monoid, Show) a => Monoid (DiffList a) where
   |           ^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:52:19: error:
    • Expecting one more argument to ‘Show’
      Expected a type, but ‘Show’ has kind ‘* -> Constraint’
    • In the instance declaration for ‘Monoid (DiffList a)’
   |
52 | instance (Monoid, Show) a => Monoid (DiffList a) where
   |                   ^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:55:10: error:
    • Expected kind ‘* -> Constraint’,
        but ‘(Monoid, Show)’ has kind ‘*’
    • In the instance declaration for ‘Semigroup (DiffList a)’
   |
55 | instance (Monoid, Show) a => Semigroup (DiffList a) where
   |          ^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:55:11: error:
    • Expecting one more argument to ‘Monoid’
      Expected a type, but ‘Monoid’ has kind ‘* -> Constraint’
    • In the instance declaration for ‘Semigroup (DiffList a)’
   |
55 | instance (Monoid, Show) a => Semigroup (DiffList a) where
   |           ^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:55:19: error:
    • Expecting one more argument to ‘Show’
      Expected a type, but ‘Show’ has kind ‘* -> Constraint’
    • In the instance declaration for ‘Semigroup (DiffList a)’
   |
55 | instance (Monoid, Show) a => Semigroup (DiffList a) where
   |                   ^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])

<interactive>:78:1: error:
    • Ambiguous type variable ‘a0’ arising from a use of ‘print’
      prevents the constraint ‘(Show a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      These potential instances exist:
        instance (Show a, Show b) => Show (Either a b)
          -- Defined in ‘Data.Either’
        instance forall k (f :: k -> *) (a :: k).
                 Show (f a) =>
                 Show (Ap f a)
          -- Defined in ‘Data.Monoid’
        instance Show a => Show (First a) -- Defined in ‘Data.Monoid’
        ...plus 32 others
        ...plus 66 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In a stmt of an interactive GHCi command: print it
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])

<interactive>:80:1: error:
    • Ambiguous type variable ‘a0’ arising from a use of ‘print’
      prevents the constraint ‘(Show a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      These potential instances exist:
        instance (Show a, Show b) => Show (Either a b)
          -- Defined in ‘Data.Either’
        instance forall k (f :: k -> *) (a :: k).
                 Show (f a) =>
                 Show (Ap f a)
          -- Defined in ‘Data.Monoid’
        instance Show a => Show (First a) -- Defined in ‘Data.Monoid’
        ...plus 32 others
        ...plus 66 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In a stmt of an interactive GHCi command: print it
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3]) :: []

<interactive>:81:69: error:
    • Expecting one more argument to ‘[]’
      Expected a type, but ‘[]’ has kind ‘* -> *’
    • In an expression type signature: []
      In the expression:
          fromDiffList
            (toDiffList [1, 2, 3, ....] `mappend` toDiffList [1, 2, 3]) ::
            []
      In an equation for ‘it’:
          it
            = fromDiffList
                (toDiffList [1, 2, ....] `mappend` toDiffList [1, 2, ....]) ::
                []
*Main Lib Paths_HaskellForGreaterGood> :t []
[] :: [a]
*Main Lib Paths_HaskellForGreaterGood> :t List

<interactive>:1:1: error:
    • Data constructor not in scope: List
    • Perhaps you meant ‘Last’ (imported from Data.Monoid)
*Main Lib Paths_HaskellForGreaterGood> :i []
type [] :: * -> *
data [] a = [] | a : [a]
  	-- Defined in ‘ghc-prim-0.6.1:GHC.Types’
instance Applicative [] -- Defined in ‘GHC.Base’
instance Eq a => Eq [a] -- Defined in ‘ghc-prim-0.6.1:GHC.Classes’
instance Functor [] -- Defined in ‘GHC.Base’
instance Monad [] -- Defined in ‘GHC.Base’
instance Monoid [a] -- Defined in ‘GHC.Base’
instance Ord a => Ord [a]
  -- Defined in ‘ghc-prim-0.6.1:GHC.Classes’
instance Semigroup [a] -- Defined in ‘GHC.Base’
instance Show a => Show [a] -- Defined in ‘GHC.Show’
instance MonadFail [] -- Defined in ‘Control.Monad.Fail’
instance Read a => Read [a] -- Defined in ‘GHC.Read’
instance Traversable [] -- Defined in ‘Data.Traversable’
instance Foldable [] -- Defined in ‘Data.Foldable’
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3]) :: Traversal

<interactive>:85:69: error:
    Not in scope: type constructor or class ‘Traversal’
    Perhaps you meant ‘Traversable’ (imported from Prelude)
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3]) :: Traversable

<interactive>:86:69: error:
    • Expecting one more argument to ‘Traversable’
      Expected a type, but
      ‘Traversable’ has kind
      ‘(* -> *) -> Constraint’
    • In an expression type signature: Traversable
      In the expression:
          fromDiffList
            (toDiffList [1, 2, 3, ....] `mappend` toDiffList [1, 2, 3]) ::
            Traversable
      In an equation for ‘it’:
          it
            = fromDiffList
                (toDiffList [1, 2, ....] `mappend` toDiffList [1, 2, ....]) ::
                Traversable
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3]) :: []

<interactive>:87:69: error:
    • Expecting one more argument to ‘[]’
      Expected a type, but ‘[]’ has kind ‘* -> *’
    • In an expression type signature: []
      In the expression:
          fromDiffList
            (toDiffList [1, 2, 3, ....] `mappend` toDiffList [1, 2, 3]) ::
            []
      In an equation for ‘it’:
          it
            = fromDiffList
                (toDiffList [1, 2, ....] `mappend` toDiffList [1, 2, ....]) ::
                []
*Main Lib Paths_HaskellForGreaterGood> show $ fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])

<interactive>:88:1: error:
    • Ambiguous type variable ‘a0’ arising from a use of ‘show’
      prevents the constraint ‘(Show a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      These potential instances exist:
        instance (Show a, Show b) => Show (Either a b)
          -- Defined in ‘Data.Either’
        instance forall k (f :: k -> *) (a :: k).
                 Show (f a) =>
                 Show (Ap f a)
          -- Defined in ‘Data.Monoid’
        instance Show a => Show (First a) -- Defined in ‘Data.Monoid’
        ...plus 32 others
        ...plus 75 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression:
        show
          $ fromDiffList
              (toDiffList [1, 2, 3, 4] `mappend` toDiffList [1, 2, 3])
      In an equation for ‘it’:
          it
            = show
                $ fromDiffList
                    (toDiffList [1, 2, 3, ....] `mappend` toDiffList [1, 2, 3])

<interactive>:88:22: error:
    • Ambiguous type variable ‘a0’ arising from a use of ‘mappend’
      prevents the constraint ‘(Monoid a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      These potential instances exist:
        instance Monoid (First a) -- Defined in ‘Data.Monoid’
        instance Monoid (Last a) -- Defined in ‘Data.Monoid’
        instance Monoid All
          -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
        ...plus 16 others
        ...plus 14 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘fromDiffList’, namely
        ‘(toDiffList [1, 2, 3, 4] `mappend` toDiffList [1, 2, 3])’
      In the second argument of ‘($)’, namely
        ‘fromDiffList
           (toDiffList [1, 2, 3, 4] `mappend` toDiffList [1, 2, 3])’
      In the expression:
        show
          $ fromDiffList
              (toDiffList [1, 2, 3, 4] `mappend` toDiffList [1, 2, 3])

<interactive>:88:34: error:
    • Ambiguous type variable ‘a0’ arising from the literal ‘1’
      prevents the constraint ‘(Num a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      These potential instances exist:
        instance forall k (f :: k -> *) (a :: k).
                 Num (f a) =>
                 Num (Alt f a)
          -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
        instance Num a => Num (Product a)
          -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
        instance Num a => Num (Sum a)
          -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
        ...plus five others
        ...plus 14 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: 1
      In the first argument of ‘toDiffList’, namely ‘[1, 2, 3, 4]’
      In the first argument of ‘mappend’, namely
        ‘toDiffList [1, 2, 3, 4]’
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> :t Num

<interactive>:1:1: error:
    • Data constructor not in scope: Num
    • Perhaps you meant one of these:
        ‘Sum’ (imported from Data.Monoid),
        variable ‘sum’ (imported from Prelude)
*Main Lib Paths_HaskellForGreaterGood> :i Num
type Num :: * -> Constraint
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
instance Num Word -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Int -- Defined in ‘GHC.Num’
instance Num a => Num (Sum a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Num a => Num (Product a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance forall k (f :: k -> *) (a :: k).
         Num (f a) =>
         Num (Alt f a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance (Applicative f, Num a) => Num (Ap f a)
  -- Defined in ‘Data.Monoid’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Double -- Defined in ‘GHC.Float’
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> :e
editor not set, use :set editor
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> mapM_ putStrLn $ snd $ runWriter (gcdReverse 8 3)
Finished with 1
2 mod 1 = 0
3 mod 2 = 1
8 mod 3 = 2
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])

<interactive>:97:1: error:
    • Ambiguous type variable ‘a0’ arising from a use of ‘print’
      prevents the constraint ‘(Show a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      These potential instances exist:
        instance (Show a, Show b) => Show (Either a b)
          -- Defined in ‘Data.Either’
        instance forall k (f :: k -> *) (a :: k).
                 Show (f a) =>
                 Show (Ap f a)
          -- Defined in ‘Data.Monoid’
        instance Show a => Show (First a) -- Defined in ‘Data.Monoid’
        ...plus 32 others
        ...plus 75 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In a stmt of an interactive GHCi command: print it
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> Lr

<interactive>:99:1: error:
    • Data constructor not in scope: Lr
    • Perhaps you meant one of these:
        ‘LT’ (imported from Prelude), variable ‘or’ (imported from Prelude)
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:51:70: error:
    • No instance for (Show ([a] -> [a]))
        arising from the first field of ‘DiffList’ (type ‘[a] -> [a]’)
        (maybe you haven't applied a function to enough arguments?)
      Possible fix:
        use a standalone 'deriving instance' declaration,
          so you can specify the instance context yourself
    • When deriving the instance for (Show (DiffList a))
   |
51 | newtype DiffList a = DiffList { getDiffList :: [a] -> [a] } deriving Show
   |                                                                      ^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood>  Ambiguous type variable ‘a0’ arising from a use of ‘print

<interactive>:102:12: error: parse error on input ‘type’
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])

<interactive>:104:1: error:
    Variable not in scope: fromDiffList :: t0 -> t

<interactive>:104:15: error:
    Variable not in scope: toDiffList :: [a0] -> t0

<interactive>:104:46: error:
    Variable not in scope: toDiffList :: [a1] -> t0
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:51:70: error:
    • No instance for (Show ([a] -> [a]))
        arising from the first field of ‘DiffList’ (type ‘[a] -> [a]’)
        (maybe you haven't applied a function to enough arguments?)
      Possible fix:
        use a standalone 'deriving instance' declaration,
          so you can specify the instance context yourself
    • When deriving the instance for (Show (DiffList a))
   |
51 | newtype DiffList a = DiffList { getDiffList :: [a] -> [a] } deriving Show
   |                                                                      ^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])

<interactive>:106:1: error:
    Variable not in scope: fromDiffList :: t0 -> t

<interactive>:106:15: error:
    Variable not in scope: toDiffList :: [a0] -> t0

<interactive>:106:46: error:
    Variable not in scope: toDiffList :: [a1] -> t0
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])

<interactive>:108:1: error:
    • Ambiguous type variable ‘a0’ arising from a use of ‘print’
      prevents the constraint ‘(Show a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      These potential instances exist:
        instance (Show a, Show b) => Show (Either a b)
          -- Defined in ‘Data.Either’
        instance forall k (f :: k -> *) (a :: k).
                 Show (f a) =>
                 Show (Ap f a)
          -- Defined in ‘Data.Monoid’
        instance Show a => Show (First a) -- Defined in ‘Data.Monoid’
        ...plus 32 others
        ...plus 75 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In a stmt of an interactive GHCi command: print it
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:60:37: error:
    • Expecting one more argument to ‘[]’
      Expected a type, but ‘[]’ has kind ‘* -> *’
    • In an expression type signature: []
      In the expression: f [] :: []
      In an equation for ‘fromDiffList’:
          fromDiffList (DiffList f) = f [] :: []
   |
60 | fromDiffList (DiffList f) = f [] :: []
   |                                     ^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:59:17: warning: [-Wsimplifiable-class-constraints]
    • The constraint ‘Show [a]’ matches
        instance Show a => Show [a] -- Defined in ‘GHC.Show’
      This makes type inference for inner bindings fragile;
        either use MonoLocalBinds, or simplify it using the instance
    • In the type signature:
        fromDiffList :: Show [a] => DiffList a -> [a]
   |
59 | fromDiffList :: Show [a] => DiffList a -> [a]
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])

<interactive>:114:1: error:
    • Ambiguous type variable ‘a0’ arising from a use of ‘print’
      prevents the constraint ‘(Show a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      These potential instances exist:
        instance (Show a, Show b) => Show (Either a b)
          -- Defined in ‘Data.Either’
        instance forall k (f :: k -> *) (a :: k).
                 Show (f a) =>
                 Show (Ap f a)
          -- Defined in ‘Data.Monoid’
        instance Show a => Show (First a) -- Defined in ‘Data.Monoid’
        ...plus 32 others
        ...plus 75 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In a stmt of an interactive GHCi command: print it
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:51:71: error:
    • No instance for (Show ([a] -> [a]))
        arising from the first field of ‘DiffList’ (type ‘[a] -> [a]’)
        (maybe you haven't applied a function to enough arguments?)
      Possible fix:
        use a standalone 'deriving instance' declaration,
          so you can specify the instance context yourself
    • When deriving the instance for (Show (DiffList a))
   |
51 | newtype DiffList a = DiffList { getDiffList :: [a] -> [a] } deriving (Show)
   |                                                                       ^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:51:71: error:
    • ‘Show (DiffList a)’ is not a unary constraint, as expected by a deriving clause
    • In the newtype declaration for ‘DiffList’
   |
51 | newtype DiffList a = DiffList { getDiffList :: [a] -> [a] } deriving (Show (DiffList a))
   |                                                                       ^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:51:71: error:
    • ‘Show [a]’ is not a unary constraint, as expected by a deriving clause
    • In the newtype declaration for ‘DiffList’
   |
51 | newtype DiffList a = DiffList { getDiffList :: [a] -> [a] } deriving (Show [a])
   |                                                                       ^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:51:70: error:
    • No instance for (Show ([a] -> [a]))
        arising from the first field of ‘DiffList’ (type ‘[a] -> [a]’)
        (maybe you haven't applied a function to enough arguments?)
      Possible fix:
        use a standalone 'deriving instance' declaration,
          so you can specify the instance context yourself
    • When deriving the instance for (Show (DiffList a))
   |
51 | newtype DiffList a = DiffList { getDiffList :: [a] -> [a] } deriving Show
   |                                                                      ^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:60:37: error:
    • Expecting one more argument to ‘Show’
      Expected a type, but ‘Show’ has kind ‘* -> Constraint’
    • In an expression type signature: Show
      In the expression: f [] :: Show
      In an equation for ‘fromDiffList’:
          fromDiffList (DiffList f) = f [] :: Show
   |
60 | fromDiffList (DiffList f) = f [] :: Show
   |                                     ^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:60:37: error:
    • Expected a type, but ‘Show []’ has kind ‘Constraint’
    • In an expression type signature: Show []
      In the expression: f [] :: Show []
      In an equation for ‘fromDiffList’:
          fromDiffList (DiffList f) = f [] :: Show []
   |
60 | fromDiffList (DiffList f) = f [] :: Show []
   |                                     ^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:60:42: error:
    • Expecting one more argument to ‘[]’
      Expected a type, but ‘[]’ has kind ‘* -> *’
    • In the first argument of ‘Show’, namely ‘[]’
      In an expression type signature: Show []
      In the expression: f [] :: Show []
   |
60 | fromDiffList (DiffList f) = f [] :: Show []
   |                                          ^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :k Show
Show :: * -> Constraint
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :k DiffList

<interactive>:1:1: error:
    Not in scope: type constructor or class ‘DiffList’
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :t DiffList

<interactive>:1:1: error: Data constructor not in scope: DiffList
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:60:37: error:
    • Expected a type, but ‘Show (getDiffList)’ has kind ‘Constraint’
    • In an expression type signature: Show (getDiffList)
      In the expression: f [] :: Show (getDiffList)
      In an equation for ‘fromDiffList’:
          fromDiffList (DiffList f) = f [] :: Show (getDiffList)
   |
60 | fromDiffList (DiffList f) = f [] :: Show (getDiffList)
   |                                     ^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :t Show

<interactive>:1:1: error:
    • Data constructor not in scope: Show
    • Perhaps you meant variable ‘show’ (imported from Prelude)
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :i Show
type Show :: * -> Constraint
class Show a where
  showsPrec :: Int -> a -> ShowS
  show :: a -> String
  showList :: [a] -> ShowS
  {-# MINIMAL showsPrec | show #-}
  	-- Defined in ‘GHC.Show’
instance (Show a, Show b) => Show (Either a b)
  -- Defined in ‘Data.Either’
instance Show a => Show [a] -- Defined in ‘GHC.Show’
instance Show Word -- Defined in ‘GHC.Show’
instance Show ghc-prim-0.6.1:GHC.Types.RuntimeRep
  -- Defined in ‘GHC.Show’
instance Show Ordering -- Defined in ‘GHC.Show’
instance Show a => Show (Maybe a) -- Defined in ‘GHC.Show’
instance Show Integer -- Defined in ‘GHC.Show’
instance Show Int -- Defined in ‘GHC.Show’
instance Show Char -- Defined in ‘GHC.Show’
instance Show Bool -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i, Show j, Show k, Show l, Show m, Show n, Show o) =>
         Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i, Show j, Show k, Show l, Show m, Show n) =>
         Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i, Show j, Show k, Show l, Show m) =>
         Show (a, b, c, d, e, f, g, h, i, j, k, l, m)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i, Show j, Show k, Show l) =>
         Show (a, b, c, d, e, f, g, h, i, j, k, l)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i, Show j, Show k) =>
         Show (a, b, c, d, e, f, g, h, i, j, k)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i, Show j) =>
         Show (a, b, c, d, e, f, g, h, i, j)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i) =>
         Show (a, b, c, d, e, f, g, h, i)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h) =>
         Show (a, b, c, d, e, f, g, h)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f,
          Show g) =>
         Show (a, b, c, d, e, f, g)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f) =>
         Show (a, b, c, d, e, f)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e) =>
         Show (a, b, c, d, e)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d) => Show (a, b, c, d)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c) => Show (a, b, c)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b) => Show (a, b) -- Defined in ‘GHC.Show’
instance Show () -- Defined in ‘GHC.Show’
instance Show Exception.SomeException
  -- Defined in ‘GHC.Exception.Type’
instance Show Exception.ArithException
  -- Defined in ‘GHC.Exception.Type’
instance Show Exception.SomeAsyncException
  -- Defined in ‘GHC.IO.Exception’
instance Show Exception.IOException
  -- Defined in ‘GHC.IO.Exception’
instance Show Exception.Deadlock -- Defined in ‘GHC.IO.Exception’
instance Show Exception.CompactionFailed
  -- Defined in ‘GHC.IO.Exception’
instance Show Exception.BlockedIndefinitelyOnSTM
  -- Defined in ‘GHC.IO.Exception’
instance Show Exception.BlockedIndefinitelyOnMVar
  -- Defined in ‘GHC.IO.Exception’
instance Show Exception.AsyncException
  -- Defined in ‘GHC.IO.Exception’
instance Show Exception.AssertionFailed
  -- Defined in ‘GHC.IO.Exception’
instance Show Exception.ArrayException
  -- Defined in ‘GHC.IO.Exception’
instance Show Exception.AllocationLimitExceeded
  -- Defined in ‘GHC.IO.Exception’
instance Show Exception.MaskingState -- Defined in ‘GHC.IO’
instance [safe] Show Version -- Defined in ‘Data.Version’
instance Show Float -- Defined in ‘GHC.Float’
instance Show Double -- Defined in ‘GHC.Float’
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:81:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
   |
81 | main :: IO ()
   | ^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:52:10: error:
    • Expected kind ‘* -> Constraint’, but ‘String’ has kind ‘*’
    • In the instance declaration for ‘Monoid (DiffList a)’
   |
52 | instance String a => Monoid (DiffList a) where
   |          ^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:55:10: error:
    • Expected kind ‘* -> Constraint’, but ‘String’ has kind ‘*’
    • In the instance declaration for ‘Semigroup (DiffList a)’
   |
55 | instance String a => Semigroup (DiffList a) where
   |          ^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :i String
type String :: *
type String = [Char]
  	-- Defined in ‘GHC.Base’
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:52:10: error:
    • Expected a constraint, but ‘[] a’ has kind ‘*’
    • In the instance declaration for ‘Monoid (DiffList a)’
   |
52 | instance [] a => Monoid (DiffList a) where
   |          ^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:55:10: error:
    • Expected a constraint, but ‘[] a’ has kind ‘*’
    • In the instance declaration for ‘Semigroup (DiffList a)’
   |
55 | instance [] a => Semigroup (DiffList a) where
   |          ^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])

<interactive>:138:1: error:
    Variable not in scope: fromDiffList :: t0 -> t

<interactive>:138:15: error:
    Variable not in scope: toDiffList :: [a0] -> t0

<interactive>:138:46: error:
    Variable not in scope: toDiffList :: [a1] -> t0
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:7: error:
    • Couldn't match type ‘[String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [String] Int
    • In a stmt of a 'do' block:
        tell (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tell (toDiffList ["Finished with " ++ show a])
           return a
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tell (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tell
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
74 |       tell (toDiffList ["Finished with " ++ show a])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:13: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tell’, namely
        ‘(toDiffList ["Finished with " ++ show a])’
      In a stmt of a 'do' block:
        tell (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tell (toDiffList ["Finished with " ++ show a])
           return a
   |
74 |       tell (toDiffList ["Finished with " ++ show a])
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:78:7: error:
    • Couldn't match type ‘[String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [String] Int
    • In a stmt of a 'do' block:
        tell
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tell
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tell (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tell
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
78 |       tell (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:78:13: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tell’, namely
        ‘(toDiffList
            [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])’
      In a stmt of a 'do' block:
        tell
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tell
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
   |
78 |       tell (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:67:19: error:
    Unexpected do block in function application:
        do result <- gcdReverse b (a `mod` b)
           tell [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)]
           return result
    You could write it with parentheses
    Or perhaps you meant to enable BlockArguments?
   |
67 |     | otherwise = do  
   |                   ^^^^...
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])
[1,2,3,4,1,2,3]
*Main Lib Paths_HaskellForGreaterGood> :t Num

<interactive>:1:1: error:
    • Data constructor not in scope: Num
    • Perhaps you meant one of these:
        ‘Sum’ (imported from Data.Monoid),
        variable ‘sum’ (imported from Prelude)
*Main Lib Paths_HaskellForGreaterGood> :i Num
type Num :: * -> Constraint
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
instance Num Word -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Int -- Defined in ‘GHC.Num’
instance Num a => Num (Sum a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Num a => Num (Product a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance forall k (f :: k -> *) (a :: k).
         Num (f a) =>
         Num (Alt f a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance (Applicative f, Num a) => Num (Ap f a)
  -- Defined in ‘Data.Monoid’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Double -- Defined in ‘GHC.Float’
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> :i String
type String :: *
type String = [Char]
  	-- Defined in ‘GHC.Base’
*Main Lib Paths_HaskellForGreaterGood> :i Show
type Show :: * -> Constraint
class Show a where
  showsPrec :: Int -> a -> ShowS
  show :: a -> String
  showList :: [a] -> ShowS
  {-# MINIMAL showsPrec | show #-}
  	-- Defined in ‘GHC.Show’
instance (Show a, Show b) => Show (Either a b)
  -- Defined in ‘Data.Either’
instance Show a => Show [a] -- Defined in ‘GHC.Show’
instance Show Word -- Defined in ‘GHC.Show’
instance Show ghc-prim-0.6.1:GHC.Types.RuntimeRep
  -- Defined in ‘GHC.Show’
instance Show Ordering -- Defined in ‘GHC.Show’
instance Show a => Show (Maybe a) -- Defined in ‘GHC.Show’
instance Show Integer -- Defined in ‘GHC.Show’
instance Show Int -- Defined in ‘GHC.Show’
instance Show Char -- Defined in ‘GHC.Show’
instance Show Bool -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i, Show j, Show k, Show l, Show m, Show n, Show o) =>
         Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i, Show j, Show k, Show l, Show m, Show n) =>
         Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i, Show j, Show k, Show l, Show m) =>
         Show (a, b, c, d, e, f, g, h, i, j, k, l, m)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i, Show j, Show k, Show l) =>
         Show (a, b, c, d, e, f, g, h, i, j, k, l)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i, Show j, Show k) =>
         Show (a, b, c, d, e, f, g, h, i, j, k)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i, Show j) =>
         Show (a, b, c, d, e, f, g, h, i, j)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i) =>
         Show (a, b, c, d, e, f, g, h, i)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h) =>
         Show (a, b, c, d, e, f, g, h)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f,
          Show g) =>
         Show (a, b, c, d, e, f, g)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f) =>
         Show (a, b, c, d, e, f)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e) =>
         Show (a, b, c, d, e)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d) => Show (a, b, c, d)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c) => Show (a, b, c)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b) => Show (a, b) -- Defined in ‘GHC.Show’
instance Show () -- Defined in ‘GHC.Show’
instance Show a => Show (Sum a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Show a => Show (Product a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Show a => Show (Dual a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Show Any
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance forall k (f :: k -> *) (a :: k).
         Show (f a) =>
         Show (Alt f a)
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Show All
  -- Defined in ‘base-4.14.1.0:Data.Semigroup.Internal’
instance Show a => Show (Last a) -- Defined in ‘Data.Monoid’
instance Show a => Show (First a) -- Defined in ‘Data.Monoid’
instance forall k (f :: k -> *) (a :: k).
         Show (f a) =>
         Show (Ap f a)
  -- Defined in ‘Data.Monoid’
instance Show Float -- Defined in ‘GHC.Float’
instance Show Double -- Defined in ‘GHC.Float’
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])

<interactive>:150:1: error:
    • Ambiguous type variable ‘a0’ arising from a use of ‘print’
      prevents the constraint ‘(Show a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      These potential instances exist:
        instance (Show a, Show b) => Show (Either a b)
          -- Defined in ‘Data.Either’
        instance forall k (f :: k -> *) (a :: k).
                 Show (f a) =>
                 Show (Ap f a)
          -- Defined in ‘Data.Monoid’
        instance Show a => Show (First a) -- Defined in ‘Data.Monoid’
        ...plus 32 others
        ...plus 75 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In a stmt of an interactive GHCi command: print it
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:56:14: error:
    ‘<>’ is not a (visible) method of class ‘Monoid’
   |
56 |   DiffList f <> DiffList g = DiffList (\xs -> f (g xs)) 
   |              ^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])
[1,2,3,4,1,2,3]
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> mapM_ putStrLn . fromDiffList . snd . runWriter $ gcdReverse 110 34

<interactive>:156:51: error:
    • Couldn't match type ‘[String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [String] Int
    • In the second argument of ‘($)’, namely ‘gcdReverse 110 34’
      In the expression:
        mapM_ putStrLn . fromDiffList . snd . runWriter $ gcdReverse 110 34
      In an equation for ‘it’:
          it
            = mapM_ putStrLn . fromDiffList . snd . runWriter
                $ gcdReverse 110 34
*Main Lib Paths_HaskellForGreaterGood> mapM_ putStrLn . fromDiffList . snd . runWriter $ (gcdReverse 110 34)

<interactive>:157:52: error:
    • Couldn't match type ‘[String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [String] Int
    • In the second argument of ‘($)’, namely ‘(gcdReverse 110 34)’
      In the expression:
        mapM_ putStrLn . fromDiffList . snd . runWriter
          $ (gcdReverse 110 34)
      In an equation for ‘it’:
          it
            = mapM_ putStrLn . fromDiffList . snd . runWriter
                $ (gcdReverse 110 34)
*Main Lib Paths_HaskellForGreaterGood> :t runWriter
runWriter :: Writer w a -> (a, w)
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:7: error:
    • Couldn't match type ‘[String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [String] Int
    • In a stmt of a 'do' block:
        tell (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tell (toDiffList ["Finished with " ++ show a])
           return a
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tell (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tell
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |
74 |       tell (toDiffList ["Finished with " ++ show a])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:13: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tell’, namely
        ‘(toDiffList ["Finished with " ++ show a])’
      In a stmt of a 'do' block:
        tell (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tell (toDiffList ["Finished with " ++ show a])
           return a
   |
74 |       tell (toDiffList ["Finished with " ++ show a])
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:78:7: error:
    • Couldn't match type ‘[String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [String] Int
    • In a stmt of a 'do' block:
        tell
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tell
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tell (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tell
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |
78 |       tell (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:78:13: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tell’, namely
        ‘(toDiffList
            [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])’
      In a stmt of a 'do' block:
        tell
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tell
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |
78 |       tell (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:75:7: error:
    • Couldn't match type ‘[String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [String] Int
    • In a stmt of a 'do' block:
        tell (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tell (toDiffList ["Finished with " ++ show a])
           return a
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tell (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tell
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
75 |       tell (toDiffList ["Finished with " ++ show a])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:75:13: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tell’, namely
        ‘(toDiffList ["Finished with " ++ show a])’
      In a stmt of a 'do' block:
        tell (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tell (toDiffList ["Finished with " ++ show a])
           return a
   |
75 |       tell (toDiffList ["Finished with " ++ show a])
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:7: error:
    • Couldn't match type ‘[String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [String] Int
    • In a stmt of a 'do' block:
        tell
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tell
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tell (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tell
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
79 |       tell (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:13: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tell’, namely
        ‘(toDiffList
            [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])’
      In a stmt of a 'do' block:
        tell
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tell
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
   |
79 |       tell (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:11: error:
    • Couldn't match type ‘[Char]’ with ‘DiffList String’
      Expected type: Writer [DiffList String] Int
        Actual type: Writer [String] Int
    • In the expression: Writer (1, w)
      In an equation for ‘tellp’: tellp w = Writer (1, w)
   |
74 | tellp w = Writer (1, w)
   |           ^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:14: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList ["Finished with " ++ show a])’
      In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:14: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList
            [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])’
      In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:11: error:
    • Couldn't match type ‘DiffList a0’ with ‘[DiffList String]’
      Expected type: Writer [DiffList String] Int
        Actual type: Writer (DiffList a0) Int
    • In the expression: Writer (1, DiffList w)
      In an equation for ‘tellp’: tellp w = Writer (1, DiffList w)
   |
74 | tellp w = Writer (1, DiffList w)
   |           ^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:31: error:
    • Couldn't match expected type ‘[a0] -> [a0]’
                  with actual type ‘[String]’
    • In the first argument of ‘DiffList’, namely ‘w’
      In the expression: DiffList w
      In the first argument of ‘Writer’, namely ‘(1, DiffList w)’
   |
74 | tellp w = Writer (1, DiffList w)
   |                               ^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:14: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList ["Finished with " ++ show a])’
      In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:14: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList
            [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])’
      In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> R

<interactive>:167:1: error: Data constructor not in scope: R
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:11: error:
    • Couldn't match type ‘DiffList a0’ with ‘[DiffList String]’
      Expected type: Writer [DiffList String] Int
        Actual type: Writer (DiffList a0) Int
    • In the expression: Writer (1, DiffList w)
      In an equation for ‘tellp’: tellp w = Writer (1, DiffList w)
   |
74 | tellp w = Writer (1, DiffList w)
   |           ^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:31: error:
    • Couldn't match type ‘[Char]’ with ‘[a0] -> [a0]’
      Expected type: [a0] -> [a0]
        Actual type: String
    • In the first argument of ‘DiffList’, namely ‘w’
      In the expression: DiffList w
      In the first argument of ‘Writer’, namely ‘(1, DiffList w)’
   |
74 | tellp w = Writer (1, DiffList w)
   |                               ^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:14: error:
    • Couldn't match type ‘DiffList [Char]’ with ‘[Char]’
      Expected type: String
        Actual type: DiffList [Char]
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList ["Finished with " ++ show a])’
      In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:14: error:
    • Couldn't match type ‘DiffList [Char]’ with ‘[Char]’
      Expected type: String
        Actual type: DiffList [Char]
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList
            [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])’
      In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:11: error:
    • Couldn't match type ‘DiffList a0’ with ‘[DiffList String]’
      Expected type: Writer [DiffList String] Int
        Actual type: Writer (DiffList a0) Int
    • In the expression: Writer (1, DiffList _a)
      In an equation for ‘tellp’: tellp w = Writer (1, DiffList _a)
   |
74 | tellp w = Writer (1, DiffList _a)
   |           ^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:31: error:
    • Found hole: _a :: [a0] -> [a0]
      Where: ‘a0’ is an ambiguous type variable
      Or perhaps ‘_a’ is mis-spelled, or not in scope
    • In the first argument of ‘DiffList’, namely ‘_a’
      In the expression: DiffList _a
      In the first argument of ‘Writer’, namely ‘(1, DiffList _a)’
    • Relevant bindings include
        w :: String
          (bound at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:7)
        tellp :: String -> Writer [DiffList String] Int
          (bound at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:1)
   |
74 | tellp w = Writer (1, DiffList _a)
   |                               ^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
:r        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:14: error:
    • Couldn't match type ‘DiffList [Char]’ with ‘[Char]’
      Expected type: String
        Actual type: DiffList [Char]
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList ["Finished with " ++ show a])’
      In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:14: error:
    • Couldn't match type ‘DiffList [Char]’ with ‘[Char]’
      Expected type: String
        Actual type: DiffList [Char]
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList
            [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])’
      In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:34: error:
    Variable not in scope: x :: [a0]
   |
74 | tellp w = Writer (1, DiffList (++x))
   |                                  ^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:11: error:
    • Couldn't match type ‘DiffList Char’ with ‘[DiffList String]’
      Expected type: Writer [DiffList String] Int
        Actual type: Writer (DiffList Char) Int
    • In the expression: Writer (1, DiffList (++ w))
      In an equation for ‘tellp’: tellp w = Writer (1, DiffList (++ w))
   |
74 | tellp w = Writer (1, DiffList (++w))
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:14: error:
    • Couldn't match type ‘DiffList [Char]’ with ‘[Char]’
      Expected type: String
        Actual type: DiffList [Char]
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList ["Finished with " ++ show a])’
      In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:14: error:
    • Couldn't match type ‘DiffList [Char]’ with ‘[Char]’
      Expected type: String
        Actual type: DiffList [Char]
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList
            [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])’
      In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:11: error:
    • Couldn't match type ‘DiffList String’ with ‘[DiffList String]’
      Expected type: Writer [DiffList String] Int
        Actual type: Writer (DiffList String) Int
    • In the expression: Writer (1, DiffList (++ w))
      In an equation for ‘tellp’: tellp w = Writer (1, DiffList (++ w))
   |
74 | tellp w = Writer (1, DiffList (++w))
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:14: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList ["Finished with " ++ show a])’
      In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:14: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList
            [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])’
      In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> clear

<interactive>:176:1: error: Variable not in scope: clear
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp:r (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:14: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList ["Finished with " ++ show a])’
      In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:14: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList
            [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])’
      In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:11: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In the expression: Writer (1, [DiffList (++ w)])
      In an equation for ‘tellp’: tellp w = Writer (1, [DiffList (++ w)])
   |
74 | tellp w = Writer (1, [DiffList (++w)])
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:14: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList ["Finished with " ++ show a])’
      In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:14: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList
            [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])’
      In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:14: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList ["Finished with " ++ show a])’
      In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:14: error:
    • Couldn't match expected type ‘[String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList
            [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])’
      In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:74:32: error:
    • Couldn't match expected type ‘[String] -> [String]’
                  with actual type ‘[DiffList String]’
    • In the first argument of ‘DiffList’, namely ‘w’
      In the expression: DiffList w
      In the expression: [DiffList w]
   |
74 | tellp w = Writer (1, [DiffList w])
   |                                ^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:14: error:
    • Couldn't match expected type ‘[DiffList String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList ["Finished with " ++ show a])’
      In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:14: error:
    • Couldn't match expected type ‘[DiffList String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList
            [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])’
      In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:79:14: error:
    • Couldn't match expected type ‘[DiffList String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList ["Finished with " ++ show a])’
      In a stmt of a 'do' block:
        tellp (toDiffList ["Finished with " ++ show a])
      In the expression:
        do tellp (toDiffList ["Finished with " ++ show a])
           return a
   |
79 |       tellp (toDiffList ["Finished with " ++ show a])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:7: error:
    • Couldn't match type ‘[DiffList String]’ with ‘DiffList String’
      Expected type: Writer (DiffList String) Int
        Actual type: Writer [DiffList String] Int
    • In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
      In an equation for ‘gcdP’:
          gcdP a b
            | b == 0
            = do tellp (toDiffList ["Finished with " ++ show a])
                 return a
            | otherwise
            = do result <- gcdP b (a `mod` b)
                 tellp
                   (toDiffList
                      [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
                 return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:83:14: error:
    • Couldn't match expected type ‘[DiffList String]’
                  with actual type ‘DiffList [Char]’
    • In the first argument of ‘tellp’, namely
        ‘(toDiffList
            [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])’
      In a stmt of a 'do' block:
        tellp
          (toDiffList
             [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
      In the expression:
        do result <- gcdP b (a `mod` b)
           tellp
             (toDiffList
                [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
           return result
   |
83 |       tellp (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> mapM_ putStrLn . fromDiffList . snd . runWriter $ gcdP 110 34
Finished with 2
8 mod 2 = 0
34 mod 8 = 2
110 mod 34 = 8
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:89:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
   |
89 | finalCountDown x = do
   | ^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:89:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
   |
89 | finalCountDown x = do
   | ^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:88:3: error::
    • Variable not in scope:
        tellP :: DiffList [Char] -> Writer (DiffList String) ()
    • Perhaps you meant one of these:
        ‘tell’ (line 30), ‘tellp’ (line 74)
   |
88 |   tellP (toDiffList ["0"])
   |   ^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:88:3: error:
    • Variable not in scope:
        tellP :: DiffList [Char] -> Writer (DiffList String) ()
    • Perhaps you meant one of these:
        ‘tell’ (line 30), ‘tellp’ (line 74)
   |
88 |   tellP (toDiffList ["0"])
   |   ^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:91:3: error:
    • Variable not in scope:
        tellP :: DiffList String -> Writer (DiffList String) ()
    • Perhaps you meant one of these:
        ‘tell’ (line 30), ‘tellp’ (line 74)
   |
91 |   tellP (toDiffList [show x])
   |   ^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:88:3: error:
    • Variable not in scope:
        tellP :: DiffList [Char] -> Writer (DiffList String) ()
    • Perhaps you meant one of these:
        ‘tell’ (line 30), ‘tellp’ (line 74)
   |
88 |   tellP (toDiffList ["0"])
   |   ^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:91:3: error:
    • Variable not in scope:
        tellP :: DiffList String -> Writer (DiffList String) ()
    • Perhaps you meant one of these:
        ‘tell’ (line 30), ‘tellp’ (line 74)
   |
91 |   tellP (toDiffList [show x])
   |   ^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:88:3: error:
    • Couldn't match type ‘Int’ with ‘()’
      Expected type: Writer (DiffList String) ()
        Actual type: Writer (DiffList String) Int
    • In a stmt of a 'do' block: tellp (toDiffList ["0"])
      In the expression: do tellp (toDiffList ["0"])
      In an equation for ‘finalCountDown’:
          finalCountDown 0 = do tellp (toDiffList ["0"])
   |
88 |   tellp (toDiffList ["0"])
   |   ^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:91:3: error:
    • Couldn't match type ‘Int’ with ‘()’
      Expected type: Writer (DiffList String) ()
        Actual type: Writer (DiffList String) Int
    • In a stmt of a 'do' block: tellp (toDiffList [show x])
      In the expression:
        do finalCountDown (x - 1)
           tellp (toDiffList [show x])
      In an equation for ‘finalCountDown’:
          finalCountDown x
            = do finalCountDown (x - 1)
                 tellp (toDiffList [show x])
   |
91 |   tellp (toDiffList [show x])
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> 
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:88:3: error:
    • Couldn't match type ‘Int’ with ‘()’
      Expected type: Writer (DiffList String) ()
        Actual type: Writer (DiffList String) Int
    • In a stmt of a 'do' block: tellp (toDiffList ["00"])
      In the expression: do tellp (toDiffList ["00"])
      In an equation for ‘finalCountDown’:
          finalCountDown 0 = do tellp (toDiffList ["00"])
   |
88 |   tellp (toDiffList ["00"])
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:91:3: error:
    • Couldn't match type ‘Int’ with ‘()’
      Expected type: Writer (DiffList String) ()
        Actual type: Writer (DiffList String) Int
    • In a stmt of a 'do' block: tellp (toDiffList [show x])
      In the expression:
        do finalCountDown (x - 1)
           tellp (toDiffList [show x])
      In an equation for ‘finalCountDown’:
          finalCountDown x
            = do finalCountDown (x - 1)
                 tellp (toDiffList [show x])
   |
91 |   tellp (toDiffList [show x])
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> :t runState

<interactive>:1:1: error: Variable not in scope: runState
*Main Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:102:15: error:
    • Couldn't match expected type ‘State s (a1, b0)’
                  with actual type ‘s0 -> (a0, s0)’
    • Probable cause: ‘runState’ is applied to too few arguments
      In a stmt of a 'do' block: (x, y) <- runState s
      In the expression:
        do (x, y) <- runState s
           _a
      In an equation for ‘>>=’:
          (State s) >>= f
            = do (x, y) <- runState s
                 _a
    • Relevant bindings include
        f :: a -> State s b
          (bound at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:101:17)
        s :: s -> (a, s)
          (bound at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:101:10)
        (>>=) :: State s a -> (a -> State s b) -> State s b
          (bound at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:101:13)
    |
102 |     (x, y) <- runState s
    |               ^^^^^^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:102:24: error:
    • Couldn't match expected type ‘State s0 a0’
                  with actual type ‘s -> (a, s)’
    • Probable cause: ‘s’ is applied to too few arguments
      In the first argument of ‘runState’, namely ‘s’
      In a stmt of a 'do' block: (x, y) <- runState s
      In the expression:
        do (x, y) <- runState s
           _a
    • Relevant bindings include
        f :: a -> State s b
          (bound at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:101:17)
        s :: s -> (a, s)
          (bound at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:101:10)
        (>>=) :: State s a -> (a -> State s b) -> State s b
          (bound at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:101:13)
    |
102 |     (x, y) <- runState s
    |                        ^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:103:5: error:
    • Found hole: _a :: State s b
      Where: ‘b’ is a rigid type variable bound by
               the type signature for:
                 (>>=) :: forall a b. State s a -> (a -> State s b) -> State s b
               at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:101:13-15
             ‘s’ is a rigid type variable bound by
               the instance declaration
               at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:99:10-24
      Or perhaps ‘_a’ is mis-spelled, or not in scope
    • In a stmt of a 'do' block: _a
      In the expression:
        do (x, y) <- runState s
           _a
      In an equation for ‘>>=’:
          (State s) >>= f
            = do (x, y) <- runState s
                 _a
    • Relevant bindings include
        y :: b0
          (bound at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:102:9)
        x :: a1
          (bound at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:102:6)
        f :: a -> State s b
          (bound at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:101:17)
        s :: s -> (a, s)
          (bound at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:101:10)
        (>>=) :: State s a -> (a -> State s b) -> State s b
          (bound at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:101:13)
    |
103 |     _a
    |     ^^
Failed, two modules loaded.
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :t runState

<interactive>:1:1: error: Variable not in scope: runState
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :i runState

<interactive>:1:1: error: Not in scope: ‘runState’
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :t State

<interactive>:1:1: error: Data constructor not in scope: State
*Paths_HaskellForGreaterGood Lib Paths_HaskellForGreaterGood> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main Lib Paths_HaskellForGreaterGood> :t State
State :: (s -> (a, s)) -> State s a
*Main Lib Paths_HaskellForGreaterGood> :t runState
runState :: State s a -> s -> (a, s)
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> 
*Main Lib Paths_HaskellForGreaterGood> :t State
State :: (s -> (a, s)) -> State s a
*Main Lib Paths_HaskellForGreaterGood> :k State
State :: * -> * -> *
*Main Lib Paths_HaskellForGreaterGood> :k Monad
Monad :: (* -> *) -> Constraint
*Main Lib Paths_HaskellForGreaterGood> :k Int
Int :: *
*Main Lib Paths_HaskellForGreaterGood> :t Stack

<interactive>:1:1: error: Data constructor not in scope: Stack
*Main Lib Paths_HaskellForGreaterGood> :i Stack

<interactive>:1:1: error: Not in scope: ‘Stack’
*Main Lib Paths_HaskellForGreaterGood> :m + Control.Monad.State

<no location info>: error:
    Could not load module ‘Control.Monad.State’
    It is a member of the hidden package ‘mtl-2.2.2’.
    You can run ‘:set -package mtl’ to expose it.
    (Note: this unloads all the modules in the current scope.)
*Main Lib Paths_HaskellForGreaterGood> :set -package mtl
package flags have changed, resetting and loading new packages...
Prelude> :t Stack

<interactive>:1:1: error: Data constructor not in scope: Stack
Prelude> :i Stack

<interactive>:1:1: error: Not in scope: ‘Stack’
Prelude> :m + Control.Monad.State
Prelude Control.Monad.State> :t Stack

<interactive>:1:1: error: Data constructor not in scope: Stack
Prelude Control.Monad.State> :i Stack

<interactive>:1:1: error: Not in scope: ‘Stack’
Prelude Control.Monad.State> :r
Ok, no modules loaded.
Prelude Control.Monad.State> :t Stack

<interactive>:1:1: error: Data constructor not in scope: Stack
Prelude Control.Monad.State> :i Stack

<interactive>:1:1: error: Not in scope: ‘Stack’
Prelude Control.Monad.State> :e
No files to edit.
Prelude Control.Monad.State> :r
Ok, no modules loaded.
Prelude Control.Monad.State> :r
Ok, no modules loaded.
Prelude Control.Monad.State> runState stackManip [5,8,2,1]

<interactive>:233:10: error:
    Variable not in scope: stackManip :: State [a1] a
Prelude Control.Monad.State> :e
No files to edit.
Prelude Control.Monad.State> :r
Ok, no modules loaded.
Prelude Control.Monad.State> :m - Control.Monad.State
Prelude> :r
Ok, no modules loaded.
Prelude:t runState

<interactive>:1:1: error: Variable not in scope: runState
Prelude> :quit
Leaving GHCi.
~/workspace/haskel/HaskellForGreaterGood $ stack ghci
Using main module: 1. Package `HaskellForGreaterGood' component HaskellForGreaterGood:exe:HaskellForGreaterGood-exe with main-is file: /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs
HaskellForGreaterGood> configure (lib + exe)
Configuring HaskellForGreaterGood-0.1.0.0...
HaskellForGreaterGood> initial-build-steps (lib + exe)
The following GHC options are incompatible with GHCi and have not been passed to it: -threaded
Configuring GHCi with the following packages: HaskellForGreaterGood

* * * * * * * *

Warning: Multiple files use the same module name:
         * Paths_HaskellForGreaterGood found at the following paths
           * /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/autogen/Paths_HaskellForGreaterGood.hs (HaskellForGreaterGood:exe:HaskellForGreaterGood-exe)
           * /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Paths_HaskellForGreaterGood.hs (HaskellForGreaterGood:lib)
* * * * * * * *

GHCi, version 8.10.4: https://www.haskell.org/ghc/  :? for help
[1 of 3] Compiling Lib              ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Lib.hs, interpreted )
[2 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:6:1: error:
    Could not find module ‘Data.Monad.State’
    Use -v (or `:set -v` in ghci) to see a list of the files searched for.
  |
6 | import Data.Monad.State
  | ^^^^^^^^^^^^^^^^^^^^^^^
Failed, one module loaded.

<no location info>: error:
    Could not find module ‘Paths_HaskellForGreaterGood’
    It is not a module in the current program, or in any known package.
Loaded GHCi configuration from /private/var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/haskell-stack-ghci/e60d3411/ghci-script
*Lib> :set -v
*Lib> :r
*** Chasing dependencies:
Chasing modules from: */Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs,*Paths_HaskellForGreaterGood,*Lib
*** systool:cpp:
*** C pre-processor:
gcc -E -undef -traditional -Wno-invalid-pp-token -Wno-unicode -Wno-trigraphs -include /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/ghci/d66cac20/cabal_macros.h -I/Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build -I/Users/codeguru/.stack/programs/x86_64-osx/ghc-8.10.4/lib/ghc-8.10.4/base-4.14.1.0/include -I/Users/codeguru/.stack/programs/x86_64-osx/ghc-8.10.4/lib/ghc-8.10.4/integer-gmp-1.0.3.0/include -I/Users/codeguru/.stack/programs/x86_64-osx/ghc-8.10.4/lib/ghc-8.10.4/include -include /Users/codeguru/.stack/programs/x86_64-osx/ghc-8.10.4/lib/ghc-8.10.4/include/ghcversion.h -Ddarwin_BUILD_OS -Dx86_64_BUILD_ARCH -Ddarwin_HOST_OS -Dx86_64_HOST_ARCH -D__GLASGOW_HASKELL_TH__ -U__PIC__ -D__PIC__ -D__SSE__ -D__SSE2__ -include/var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/ghc96556_0/ghc_5.h -x assembler-with-cpp /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Paths_HaskellForGreaterGood.hs -o /var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/ghc96556_0/ghc_4.hscpp
!!! systool:cpp: finished in 0.82 milliseconds, allocated 0.183 megabytes
!!! Chasing dependencies: finished in 6.23 milliseconds, allocated 7.553 megabytes
Stable obj: {}
Stable BCO: {Lib}
unload: retaining objs []
unload: retaining bcos []
Ready for upsweep
  [NONREC
      ModSummary {
         ms_hs_date = 2021-07-16 13:15:46.817251781 UTC
         ms_mod = Lib,
         ms_textual_imps = [(Nothing, Prelude)]
         ms_srcimps = []
      },
   NONREC
      ModSummary {
         ms_hs_date = 2021-07-17 02:10:29.108359622 UTC
         ms_mod = Main,
         ms_textual_imps = [(Nothing, Prelude), (Nothing, Data.Monad.State),
                            (Nothing, Data.Monoid), (Nothing, Lib)]
         ms_srcimps = []
      },
   NONREC
      ModSummary {
         ms_hs_date = 2021-07-16 13:16:01.187143197 UTC
         ms_mod = Paths_HaskellForGreaterGood,
         ms_textual_imps = [(Nothing, Prelude),
                            (Nothing, System.Environment), (Nothing, Data.Version),
                            (Nothing, Control.Exception)]
         ms_srcimps = []
      }]
*** Deleting temp files:
Deleting: /var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/ghc96556_0/ghc_5.h
*** Deleting temp files:
Deleting: 
compile: input file /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs
*** Checking old interface for Main (use -ddump-hi-diffs for more details):
[2 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
*** Parser [Main]:
!!! Parser [Main]: finished in 3.57 milliseconds, allocated 5.615 megabytes
*** Renamer/typechecker [Main]:
!!! Renamer/typechecker [Main]: finished in 0.07 milliseconds, allocated 0.070 megabytes

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:6:1: error:
    Could not find module ‘Data.Monad.State’
    Locations searched:
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/global-autogen/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/global-autogen/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/global-autogen/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/global-autogen/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/autogen/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/autogen/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/autogen/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/autogen/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/HaskellForGreaterGood-exe-tmp/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/HaskellForGreaterGood-exe-tmp/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/HaskellForGreaterGood-exe-tmp/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/HaskellForGreaterGood-exe-tmp/Data/Monad/State.lhsig
  |
6 | import Data.Monad.State
  | ^^^^^^^^^^^^^^^^^^^^^^^
Upsweep partially successful.
*** Deleting temp files:
Deleting: 
Failed, one module loaded.
*Lib> :m + Control.Monad.State

<no location info>: error:
    Could not load module ‘Control.Monad.State’
    It is a member of the hidden package ‘mtl-2.2.2’.
    You can run ‘:set -package mtl’ to expose it.
    (Note: this unloads all the modules in the current scope.)
*Lib> :set -package mtl
*** initializing package database:
package flags [-package-id base-4.14.1.0{unit base-4.14.1.0 True ([])},
               -package mtl{package mtl True ([])}]
loading package database /Users/codeguru/.stack/programs/x86_64-osx/ghc-8.10.4/lib/ghc-8.10.4/package.conf.d
loading package database /Users/codeguru/.stack/snapshots/x86_64-osx/fc2449e14fde41037e27e6713371011327afbd2e01a231fef80772dd57393386/8.10.4/pkgdb
loading package database /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/install/x86_64-osx/fc2449e14fde41037e27e6713371011327afbd2e01a231fef80772dd57393386/8.10.4/pkgdb
wired-in package ghc-prim mapped to ghc-prim-0.6.1
wired-in package integer-wired-in mapped to integer-gmp-1.0.3.0
wired-in package base mapped to base-4.14.1.0
wired-in package rts mapped to rts-1.0
wired-in package template-haskell mapped to template-haskell-2.16.0.0
wired-in package ghc mapped to ghc-8.10.4
!!! initializing package database: finished in 5.07 milliseconds, allocated 3.741 megabytes
package flags have changed, resetting and loading new packages...
*** Chasing dependencies:
Chasing modules from: 
!!! Chasing dependencies: finished in 0.02 milliseconds, allocated 0.017 megabytes
Stable obj: {}
Stable BCO: {}
unload: retaining objs []
unload: retaining bcos []
Ready for upsweep []
Upsweep completely successful.
*** Deleting temp files:
Deleting: 
Loading package transformers-0.5.6.2 ... linking ... done.
Loading package mtl-2.2.2 ... linking ... done.
Prelude> :r
*** Chasing dependencies:
Chasing modules from: 
!!! Chasing dependencies: finished in 0.06 milliseconds, allocated 0.027 megabytes
Stable obj: {}
Stable BCO: {}
unload: retaining objs []
unload: retaining bcos []
Ready for upsweep []
Upsweep completely successful.
*** Deleting temp files:
Deleting: 
Ok, no modules loaded.
Prelude> :r
*** Chasing dependencies:
Chasing modules from: 
!!! Chasing dependencies: finished in 0.06 milliseconds, allocated 0.027 megabytes
Stable obj: {}
Stable BCO: {}
unload: retaining objs []
unload: retaining bcos []
Ready for upsweep []
Upsweep completely successful.
*** Deleting temp files:
Deleting: 
Ok, no modules loaded.
Prelude
Prelude> runState stackManip [5,8,2,1]
*** Parser [source]:
!!! Parser [source]: finished in 0.05 milliseconds, allocated 0.054 megabytes

<interactive>:8:1: error:
    Variable not in scope: runState :: t0 -> [a0] -> t

<interactive>:8:10: error: Variable not in scope: stackManip
Prelude>:r
*** Chasing dependencies:
Chasing modules from: 
!!! Chasing dependencies: finished in 0.05 milliseconds, allocated 0.027 megabytes
Stable obj: {}
Stable BCO: {}
unload: retaining objs []
unload: retaining bcos []
Ready for upsweep []
Upsweep completely successful.
*** Deleting temp files:
Deleting: 
Ok, no modules loaded.
Prelude> :quit
Leaving GHCi.
*** Deleting temp files:
Deleting: /var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/ghc96556_0/ghc_1.hscpp /var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/ghc96556_0/ghc_4.hscpp
*** Deleting temp dirs:
Deleting: /var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/ghc96556_0
~/workspace/haskel/HaskellForGreaterGood $ stack ghci
Using main module: 1. Package `HaskellForGreaterGood' component HaskellForGreaterGood:exe:HaskellForGreaterGood-exe with main-is file: /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs
HaskellForGreaterGood> configure (lib + exe)
Configuring HaskellForGreaterGood-0.1.0.0...
HaskellForGreaterGood> initial-build-steps (lib + exe)
The following GHC options are incompatible with GHCi and have not been passed to it: -threaded
Configuring GHCi with the following packages: HaskellForGreaterGood

* * * * * * * *

Warning: Multiple files use the same module name:
         * Paths_HaskellForGreaterGood found at the following paths
           * /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/autogen/Paths_HaskellForGreaterGood.hs (HaskellForGreaterGood:exe:HaskellForGreaterGood-exe)
           * /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Paths_HaskellForGreaterGood.hs (HaskellForGreaterGood:lib)
* * * * * * * *

GHCi, version 8.10.4: https://www.haskell.org/ghc/  :? for help
[1 of 3] Compiling Lib              ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Lib.hs, interpreted )
[2 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:6:1: error:
    Could not find module ‘Data.Monad.State’
    Use -v (or `:set -v` in ghci) to see a list of the files searched for.
  |
6 | import Data.Monad.State
  | ^^^^^^^^^^^^^^^^^^^^^^^
Failed, one module loaded.

<no location info>: error:
    Could not find module ‘Paths_HaskellForGreaterGood’
    It is not a module in the current program, or in any known package.
Loaded GHCi configuration from /private/var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/haskell-stack-ghci/e60d3411/ghci-script
*Lib> :set -v
*Lib> :r
*** Chasing dependencies:
Chasing modules from: */Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs,*Paths_HaskellForGreaterGood,*Lib
*** systool:cpp:
*** C pre-processor:
gcc -E -undef -traditional -Wno-invalid-pp-token -Wno-unicode -Wno-trigraphs -include /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/ghci/d66cac20/cabal_macros.h -I/Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build -I/Users/codeguru/.stack/programs/x86_64-osx/ghc-8.10.4/lib/ghc-8.10.4/base-4.14.1.0/include -I/Users/codeguru/.stack/programs/x86_64-osx/ghc-8.10.4/lib/ghc-8.10.4/integer-gmp-1.0.3.0/include -I/Users/codeguru/.stack/programs/x86_64-osx/ghc-8.10.4/lib/ghc-8.10.4/include -include /Users/codeguru/.stack/programs/x86_64-osx/ghc-8.10.4/lib/ghc-8.10.4/include/ghcversion.h -Ddarwin_BUILD_OS -Dx86_64_BUILD_ARCH -Ddarwin_HOST_OS -Dx86_64_HOST_ARCH -D__GLASGOW_HASKELL_TH__ -U__PIC__ -D__PIC__ -D__SSE__ -D__SSE2__ -include/var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/ghc96664_0/ghc_5.h -x assembler-with-cpp /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Paths_HaskellForGreaterGood.hs -o /var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/ghc96664_0/ghc_4.hscpp
!!! systool:cpp: finished in 0.84 milliseconds, allocated 0.183 megabytes
!!! Chasing dependencies: finished in 5.76 milliseconds, allocated 7.554 megabytes
Stable obj: {}
Stable BCO: {Lib}
unload: retaining objs []
unload: retaining bcos []
Ready for upsweep
  [NONREC
      ModSummary {
         ms_hs_date = 2021-07-16 13:15:46.817251781 UTC
         ms_mod = Lib,
         ms_textual_imps = [(Nothing, Prelude)]
         ms_srcimps = []
      },
   NONREC
      ModSummary {
         ms_hs_date = 2021-07-17 02:15:05.213690788 UTC
         ms_mod = Main,
         ms_textual_imps = [(Nothing, Prelude), (Nothing, Data.Monad.State),
                            (Nothing, Data.Monoid), (Nothing, Lib)]
         ms_srcimps = []
      },
   NONREC
      ModSummary {
         ms_hs_date = 2021-07-16 13:16:01.187143197 UTC
         ms_mod = Paths_HaskellForGreaterGood,
         ms_textual_imps = [(Nothing, Prelude),
                            (Nothing, System.Environment), (Nothing, Data.Version),
                            (Nothing, Control.Exception)]
         ms_srcimps = []
      }]
*** Deleting temp files:
Deleting: /var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/ghc96664_0/ghc_5.h
*** Deleting temp files:
Deleting: 
compile: input file /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs
*** Checking old interface for Main (use -ddump-hi-diffs for more details):
[2 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
*** Parser [Main]:
!!! Parser [Main]: finished in 3.71 milliseconds, allocated 5.549 megabytes
*** Renamer/typechecker [Main]:
!!! Renamer/typechecker [Main]: finished in 0.06 milliseconds, allocated 0.070 megabytes

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:6:1: error:
    Could not find module ‘Data.Monad.State’
    Locations searched:
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/global-autogen/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/global-autogen/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/global-autogen/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/global-autogen/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/autogen/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/autogen/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/autogen/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/autogen/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/HaskellForGreaterGood-exe-tmp/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/HaskellForGreaterGood-exe-tmp/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/HaskellForGreaterGood-exe-tmp/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/HaskellForGreaterGood-exe-tmp/Data/Monad/State.lhsig
  |
6 | import Data.Monad.State
  | ^^^^^^^^^^^^^^^^^^^^^^^
Upsweep partially successful.
*** Deleting temp files:
Deleting: 
Failed, one module loaded.
*Lib> 
*Lib> :
*** Chasing dependencies:
Chasing modules from: */Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs,*Paths_HaskellForGreaterGood,*Lib
!!! Chasing dependencies: finished in 2.33 milliseconds, allocated 2.076 megabytes
Stable obj: {}
Stable BCO: {Lib}
unload: retaining objs []
unload: retaining bcos []
Ready for upsweep
  [NONREC
      ModSummary {
         ms_hs_date = 2021-07-16 13:15:46.817251781 UTC
         ms_mod = Lib,
         ms_textual_imps = [(Nothing, Prelude)]
         ms_srcimps = []
      },
   NONREC
      ModSummary {
         ms_hs_date = 2021-07-17 02:15:05.213690788 UTC
         ms_mod = Main,
         ms_textual_imps = [(Nothing, Prelude), (Nothing, Data.Monad.State),
                            (Nothing, Data.Monoid), (Nothing, Lib)]
         ms_srcimps = []
      },
   NONREC
      ModSummary {
         ms_hs_date = 2021-07-16 13:16:01.187143197 UTC
         ms_mod = Paths_HaskellForGreaterGood,
         ms_textual_imps = [(Nothing, Prelude),
                            (Nothing, System.Environment), (Nothing, Data.Version),
                            (Nothing, Control.Exception)]
         ms_srcimps = []
      }]
*** Deleting temp files:
Deleting: 
*** Deleting temp files:
Deleting: 
compile: input file /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs
*** Checking old interface for Main (use -ddump-hi-diffs for more details):
[2 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
*** Parser [Main]:
!!! Parser [Main]: finished in 2.09 milliseconds, allocated 5.549 megabytes
*** Renamer/typechecker [Main]:
!!! Renamer/typechecker [Main]: finished in 0.08 milliseconds, allocated 0.070 megabytes

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:6:1: error:
    Could not find module ‘Data.Monad.State’
    Locations searched:
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/global-autogen/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/global-autogen/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/global-autogen/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/global-autogen/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/autogen/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/autogen/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/autogen/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/autogen/Data/Monad/State.lhsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/HaskellForGreaterGood-exe-tmp/Data/Monad/State.hs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/HaskellForGreaterGood-exe-tmp/Data/Monad/State.lhs
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/HaskellForGreaterGood-exe-tmp/Data/Monad/State.hsig
      /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/HaskellForGreaterGood-exe-tmp/Data/Monad/State.lhsig
  |
6 | import Data.Monad.State
  | ^^^^^^^^^^^^^^^^^^^^^^^
Upsweep partially successful.
*** Deleting temp files:
Deleting: 
Failed, one module loaded.
*Lib> :m + Control.Monad.State

<no location info>: error:
    Could not load module ‘Control.Monad.State’
    It is a member of the hidden package ‘mtl-2.2.2’.
    You can run ‘:set -package mtl’ to expose it.
    (Note: this unloads all the modules in the current scope.)
*Lib> :set -package mtl
*** initializing package database:
package flags [-package-id base-4.14.1.0{unit base-4.14.1.0 True ([])},
               -package mtl{package mtl True ([])}]
loading package database /Users/codeguru/.stack/programs/x86_64-osx/ghc-8.10.4/lib/ghc-8.10.4/package.conf.d
loading package database /Users/codeguru/.stack/snapshots/x86_64-osx/fc2449e14fde41037e27e6713371011327afbd2e01a231fef80772dd57393386/8.10.4/pkgdb
loading package database /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/install/x86_64-osx/fc2449e14fde41037e27e6713371011327afbd2e01a231fef80772dd57393386/8.10.4/pkgdb
wired-in package ghc-prim mapped to ghc-prim-0.6.1
wired-in package integer-wired-in mapped to integer-gmp-1.0.3.0
wired-in package base mapped to base-4.14.1.0
wired-in package rts mapped to rts-1.0
wired-in package template-haskell mapped to template-haskell-2.16.0.0
wired-in package ghc mapped to ghc-8.10.4
!!! initializing package database: finished in 4.91 milliseconds, allocated 3.741 megabytes
package flags have changed, resetting and loading new packages...
*** Chasing dependencies:
Chasing modules from: 
!!! Chasing dependencies: finished in 0.03 milliseconds, allocated 0.017 megabytes
Stable obj: {}
Stable BCO: {}
unload: retaining objs []
unload: retaining bcos []
Ready for upsweep []
Upsweep completely successful.
*** Deleting temp files:
Deleting: 
Loading package transformers-0.5.6.2 ... linking ... done.
Loading package mtl-2.2.2 ... linking ... done.
Prelude> :m + Control.Monad.State
Prelude Control.Monad.State> :r
*** Chasing dependencies:
Chasing modules from: 
!!! Chasing dependencies: finished in 0.05 milliseconds, allocated 0.027 megabytes
Stable obj: {}
Stable BCO: {}
unload: retaining objs []
unload: retaining bcos []
Ready for upsweep []
Upsweep completely successful.
*** Deleting temp files:
Deleting: 
Ok, no modules loaded.
Prelude Control.Monad.State> :r
*** Chasing dependencies:
Chasing modules from: 
!!! Chasing dependencies: finished in 0.05 milliseconds, allocated 0.027 megabytes
Stable obj: {}
Stable BCO: {}
unload: retaining objs []
unload: retaining bcos []
Ready for upsweep []
Upsweep completely successful.
*** Deleting temp files:
Deleting: 
Ok, no modules loaded.
Prelude Control.Monad.State> :r
*** Chasing dependencies:
Chasing modules from: 
!!! Chasing dependencies: finished in 0.05 milliseconds, allocated 0.027 megabytes
Stable obj: {}
Stable BCO: {}
unload: retaining objs []
unload: retaining bcos []
Ready for upsweep []
Upsweep completely successful.
*** Deleting temp files:
Deleting: 
Ok, no modules loaded.
Prelude Control.Monad.State> runState stackManip [5,8,2,1]
*** Parser [source]:
!!! Parser [source]: finished in 0.06 milliseconds, allocated 0.054 megabytes

<interactive>:11:10: error:
    Variable not in scope: stackManip :: State [a1] a
Prelude Control.Monad.State> :r
*** Chasing dependencies:
Chasing modules from: 
!!! Chasing dependencies: finished in 0.05 milliseconds, allocated 0.027 megabytes
Stable obj: {}
Stable BCO: {}
unload: retaining objs []
unload: retaining bcos []
Ready for upsweep []
Upsweep completely successful.
*** Deleting temp files:
Deleting: 
Ok, no modules loaded.
Prelude Control.Monad.State> :quit
Leaving GHCi.
*** Deleting temp files:
Deleting: /var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/ghc96664_0/ghc_1.hscpp /var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/ghc96664_0/ghc_4.hscpp
*** Deleting temp dirs:
Deleting: /var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/ghc96664_0
~/workspace/haskel/HaskellForGreaterGood $ stack ghci
Using main module: 1. Package `HaskellForGreaterGood' component HaskellForGreaterGood:exe:HaskellForGreaterGood-exe with main-is file: /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs
HaskellForGreaterGood> configure (lib + exe)
Configuring HaskellForGreaterGood-0.1.0.0...
HaskellForGreaterGood> initial-build-steps (lib + exe)
The following GHC options are incompatible with GHCi and have not been passed to it: -threaded
Configuring GHCi with the following packages: HaskellForGreaterGood

* * * * * * * *

Warning: Multiple files use the same module name:
         * Paths_HaskellForGreaterGood found at the following paths
           * /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/autogen/Paths_HaskellForGreaterGood.hs (HaskellForGreaterGood:exe:HaskellForGreaterGood-exe)
           * /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Paths_HaskellForGreaterGood.hs (HaskellForGreaterGood:lib)
* * * * * * * *

GHCi, version 8.10.4: https://www.haskell.org/ghc/  :? for help
[1 of 3] Compiling Lib              ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Lib.hs, interpreted )
[2 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:6:1: error:
    Could not load module ‘Control.Monad.State’
    It is a member of the hidden package ‘mtl-2.2.2’.
    You can run ‘:set -package mtl’ to expose it.
    (Note: this unloads all the modules in the current scope.)
    Use -v (or `:set -v` in ghci) to see a list of the files searched for.
  |
6 | import Control.Monad.State
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, one module loaded.

<no location info>: error:
    Could not find module ‘Paths_HaskellForGreaterGood’
    It is not a module in the current program, or in any known package.
Loaded GHCi configuration from /private/var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/haskell-stack-ghci/e60d3411/ghci-script
*Lib> :set -package mtl
package flags have changed, resetting and loading new packages...
Prelude> :r
Ok, no modules loaded.
Prelude> runState stackManip [5,8,2,1]

<interactive>:3:1: error:
    Variable not in scope: runState :: t0 -> [a0] -> t

<interactive>:3:10: error: Variable not in scope: stackManip
Prelude> :r
Ok, no modules loaded.
Prelude> :l Main
[1 of 2] Compiling Lib              ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Lib.hs, interpreted )
[2 of 2] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:101:19: error:
    Ambiguous occurrence ‘State’
    It could refer to
       either ‘Control.Monad.State.State’,
              imported from ‘Control.Monad.State’ at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:6:1-26
              (and originally defined in ‘transformers-0.5.6.2:Control.Monad.Trans.State.Lazy’)
           or ‘Main.State’,
              defined at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:100:1
    |
101 | instance Functor (State s) where
    |                   ^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:105:23: error:
    Ambiguous occurrence ‘State’
    It could refer to
       either ‘Control.Monad.State.State’,
              imported from ‘Control.Monad.State’ at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:6:1-26
              (and originally defined in ‘transformers-0.5.6.2:Control.Monad.Trans.State.Lazy’)
           or ‘Main.State’,
              defined at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:100:1
    |
105 | instance Applicative (State s) where
    |                       ^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:111:17: error:
    Ambiguous occurrence ‘State’
    It could refer to
       either ‘Control.Monad.State.State’,
              imported from ‘Control.Monad.State’ at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:6:1-26
              (and originally defined in ‘transformers-0.5.6.2:Control.Monad.Trans.State.Lazy’)
           or ‘Main.State’,
              defined at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:100:1
    |
111 | instance Monad (State s) where
    |                 ^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:116:8: error:
    Ambiguous occurrence ‘State’
    It could refer to
       either ‘Control.Monad.State.State’,
              imported from ‘Control.Monad.State’ at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:6:1-26
              (and originally defined in ‘transformers-0.5.6.2:Control.Monad.Trans.State.Lazy’)
           or ‘Main.State’,
              defined at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:100:1
    |
116 | pop :: State Stack Int
    |        ^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:116:14: error:
    Not in scope: type constructor or class ‘Stack’
    |
116 | pop :: State Stack Int
    |              ^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:118:16: error:
    Ambiguous occurrence ‘State’
    It could refer to
       either ‘Control.Monad.State.State’,
              imported from ‘Control.Monad.State’ at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:6:1-26
              (and originally defined in ‘transformers-0.5.6.2:Control.Monad.Trans.State.Lazy’)
           or ‘Main.State’,
              defined at /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:100:1
    |
118 | push :: Int -> State Stack Int
    |                ^^^^^

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:118:22: error:
    Not in scope: type constructor or class ‘Stack’
    |
118 | push :: Int -> State Stack Int
    |                      ^^^^^
Failed, one module loaded.
*Lib> f:quit

<interactive>:6:1: error: Variable not in scope: f

<interactive>:6:3: error:
    • Variable not in scope: quit :: [a]
    • Perhaps you meant ‘quot’ (imported from Prelude)
*Lib> :quit
Leaving GHCi.
~/workspace/haskel/HaskellForGreaterGood $ stack ghci
Using main module: 1. Package `HaskellForGreaterGood' component HaskellForGreaterGood:exe:HaskellForGreaterGood-exe with main-is file: /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs
HaskellForGreaterGood> configure (lib + exe)
Configuring HaskellForGreaterGood-0.1.0.0...
HaskellForGreaterGood> initial-build-steps (lib + exe)
The following GHC options are incompatible with GHCi and have not been passed to it: -threaded
Configuring GHCi with the following packages: HaskellForGreaterGood

* * * * * * * *

Warning: Multiple files use the same module name:
         * Paths_HaskellForGreaterGood found at the following paths
           * /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/HaskellForGreaterGood-exe/autogen/Paths_HaskellForGreaterGood.hs (HaskellForGreaterGood:exe:HaskellForGreaterGood-exe)
           * /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Paths_HaskellForGreaterGood.hs (HaskellForGreaterGood:lib)
* * * * * * * *

GHCi, version 8.10.4: https://www.haskell.org/ghc/  :? for help
[1 of 3] Compiling Lib              ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/src/Lib.hs, interpreted )
[2 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:6:1: error:
    Could not load module ‘Control.Monad.State’
    It is a member of the hidden package ‘mtl-2.2.2’.
    You can run ‘:set -package mtl’ to expose it.
    (Note: this unloads all the modules in the current scope.)
    Use -v (or `:set -v` in ghci) to see a list of the files searched for.
  |
6 | import Control.Monad.State
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, one module loaded.

<no location info>: error:
    Could not find module ‘Paths_HaskellForGreaterGood’
    It is not a module in the current program, or in any known package.
Loaded GHCi configuration from /private/var/folders/gd/9ww_l9pj2z7d5211yspgrh1c0000gp/T/haskell-stack-ghci/e60d3411/ghci-script
*Lib> :r
[2 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:6:1: error:
    Could not load module ‘Control.Monad.State’
    It is a member of the hidden package ‘mtl-2.2.2’.
    You can run ‘:set -package mtl’ to expose it.
    (Note: this unloads all the modules in the current scope.)
    Use -v (or `:set -v` in ghci) to see a list of the files searched for.
  |
6 | import Control.Monad.State
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, one module loaded.
*Lib> :r
[2 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )

/Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs:6:1: error:
    Could not load module ‘Control.Monad.State’
    It is a member of the hidden package ‘mtl-2.2.2’.
    You can run ‘:set -package mtl’ to expose it.
    (Note: this unloads all the modules in the current scope.)
    Use -v (or `:set -v` in ghci) to see a list of the files searched for.
  |
6 | import Control.Monad.State
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, one module loaded.
*Lib> :r
[2 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
[3 of 3] Compiling Paths_HaskellForGreaterGood ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/.stack-work/dist/x86_64-osx/Cabal-3.2.1.0/build/autogen/Paths_HaskellForGreaterGood.hs, interpreted )
Ok, three modules loaded.
*Main> runState stackManip [5,8,2,1]
(5,[8,2,1])
*Main> :r
[3 of 3] Compiling Main             ( /Users/codeguru/workspace/haskel/HaskellForGreaterGood/app/Main.hs, interpreted )
Ok, three modules loaded.
*Main> runState stackStuff [9,0,2,1,0]
((),[8,3,0,2,1,0])
*Main> 